<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Landscape Explorer</title>
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="preconnect" href="https://cdn.jsdelivr.net">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <link rel="stylesheet" href="common-styles.css">

    <style>
        .api-key-section {
            display: flex;
            gap: 0.25rem;
            margin-bottom: 0.75rem;
            align-items: center;
        }

        .api-key-section input {
            flex: 1;
            min-width: 150px;
            margin: 0;
            padding: 0.35rem 0.5rem;
            height: 2.25rem;
        }

        .api-key-section button {
            margin: 0;
            padding: 0.35rem 0.75rem;
            height: 2.25rem;
        }

        .api-key-status {
            padding: 0.5rem 0.75rem;
            background: rgba(107, 141, 214, 0.1);
            border: 1px solid rgba(107, 141, 214, 0.3);
            border-radius: var(--pico-border-radius);
            color: #6b8dd6;
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
        }

        #apiKeyStatus button {
            margin-top: 0.5rem;
        }

        .model-selectors {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .model-selector-group label {
            display: block;
            font-size: 0.85rem;
            font-weight: 600;
            margin-bottom: 0.15rem;
        }

        .model-selector-group select {
            margin: 0;
        }

        .header-controls {
            display: flex;
            gap: 0.75rem;
            flex-wrap: wrap;
            align-items: center;
            margin-bottom: 0.75rem;
        }

        .toggle-group {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .toggle-group input[type="checkbox"] {
            cursor: pointer;
            margin: 0;
        }

        .toggle-group label {
            cursor: pointer;
            margin: 0;
            font-size: 0.9rem;
        }

        .header-controls button {
            margin: 0;
            padding: 0.375rem 0.75rem;
        }

        .budget-display {
            padding: 0.5rem 0.75rem;
            background: rgba(107, 141, 214, 0.1);
            border: 1px solid rgba(107, 141, 214, 0.3);
            border-radius: var(--pico-border-radius);
            font-size: 0.85rem;
            margin-bottom: 0.75rem;
        }

        .budget-display summary {
            cursor: pointer;
            font-weight: 600;
            color: #6b8dd6;
            padding: 0;
        }

        .budget-details {
            margin-top: 0.35rem;
            padding: 0.35rem 0;
            font-size: 0.8rem;
        }

        .budget-details p {
            margin: 0.2rem 0;
        }

        .tree-node {
            margin-bottom: 0.75rem;
        }

        .node-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: var(--pico-card-background-color);
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            cursor: pointer;
            transition: background-color 0.2s;
            min-height: auto;
        }

        .node-header:hover {
            background-color: rgba(107, 141, 214, 0.05);
        }

        .expand-btn {
            flex-shrink: 0;
            width: 2rem;
            height: 2rem;
            padding: 0;
            border: 1px solid var(--pico-muted-border-color);
            background: var(--pico-button-background-color);
            border-radius: var(--pico-border-radius);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.9rem;
            transition: all 0.2s;
            margin: 0;
        }

        .expand-btn:hover:not(:disabled) {
            background-color: #6b8dd6;
            border-color: #6b8dd6;
            color: white;
        }

        .expand-btn:disabled {
            background-color: #f5f5f5;
            color: #ccc;
            cursor: not-allowed;
        }

        .node-info {
            flex: 1;
            min-width: 0;
        }

        .node-info h3 {
            margin: 0 0 0.1rem 0;
            font-size: 0.95rem;
            font-weight: 600;
        }

        .node-info p {
            margin: 0;
            font-size: 0.85rem;
            color: var(--pico-muted-color);
        }

        .node-content {
            margin-left: 0.75rem;
            padding-left: 0.75rem;
            border-left: 2px solid var(--pico-muted-border-color);
        }

        .node-content.hidden {
            display: none;
        }

        .expansion-card {
            background: var(--pico-card-background-color);
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 0.75rem;
            margin: 0.75rem 0;
        }

        .card-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
            flex-wrap: wrap;
            font-size: 0.8rem;
            color: var(--pico-muted-color);
        }

        .badge {
            display: inline-block;
            padding: 0.15rem 0.5rem;
            background: rgba(107, 141, 214, 0.1);
            color: #6b8dd6;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .badge.search {
            background: rgba(107, 141, 214, 0.1);
            color: #6b8dd6;
        }

        .badge.model {
            background: rgba(107, 141, 214, 0.1);
            color: #6b8dd6;
        }

        .refresh-btn {
            padding: 0.3rem 0.5rem;
            font-size: 0.75rem;
            border: 1px solid #6b8dd6;
            background: rgba(107, 141, 214, 0.1);
            color: #6b8dd6;
            cursor: pointer;
            border-radius: var(--pico-border-radius);
            margin: 0;
            font-weight: 500;
            transition: all 0.2s;
        }

        .refresh-btn:hover {
            background: #6b8dd6;
            color: white;
        }

        .expansion-card article {
            margin: 0;
        }

        .expansion-card article p,
        .expansion-card article ul,
        .expansion-card article ol {
            margin: 0.5rem 0;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .sources-section {
            margin-top: 0.75rem;
            padding-top: 0.75rem;
            border-top: 1px solid var(--pico-muted-border-color);
        }

        .sources-section summary {
            cursor: pointer;
            font-weight: 600;
            color: #6b8dd6;
            padding: 0.25rem;
            border-radius: 4px;
            user-select: none;
            font-size: 0.9rem;
        }

        .sources-section summary:hover {
            background: rgba(107, 141, 214, 0.05);
        }

        .source-list {
            list-style: none;
            padding: 0;
            margin: 0.5rem 0;
        }

        .source-item {
            padding: 0.5rem;
            background: var(--pico-card-background-color);
            border-left: 3px solid #6b8dd6;
            border-radius: 4px;
            margin-bottom: 0.5rem;
        }

        .source-item a {
            color: #6b8dd6;
            text-decoration: none;
            font-weight: 500;
            display: block;
            margin-bottom: 0.15rem;
            font-size: 0.9rem;
        }

        .source-item a:hover {
            text-decoration: underline;
        }

        .source-excerpt {
            font-size: 0.8rem;
            color: var(--pico-muted-color);
            margin: 0.1rem 0;
            font-style: italic;
        }

        .source-domain {
            font-size: 0.75rem;
            color: var(--pico-muted-color);
            display: block;
            margin-top: 0.15rem;
        }

        .second-opinion-btn {
            padding: 0.375rem 0.75rem;
            font-size: 0.85rem;
            margin-top: 0.75rem;
        }

        .tabs {
            display: flex;
            border-bottom: 2px solid var(--pico-muted-border-color);
            margin-bottom: 0.5rem;
            gap: 0.25rem;
        }

        .tab-btn {
            padding: 0.5rem 0.75rem;
            border: none;
            background: none;
            cursor: pointer;
            color: var(--pico-muted-color);
            font-weight: 500;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            font-size: 0.85rem;
        }

        .tab-btn.active {
            color: #6b8dd6;
            border-bottom-color: #6b8dd6;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .setup-section {
            margin-top: 1.5rem;
            border: 1px solid var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 0.75rem;
        }

        .setup-section summary {
            cursor: pointer;
            font-weight: 600;
            list-style-type: disclosure-closed;
        }

        .setup-section[open] summary {
            list-style-type: disclosure-open;
        }

        .setup-content {
            margin-top: 0.5rem;
            font-size: 0.9rem;
        }

        .setup-content p,
        .setup-content li {
            margin: 0.3rem 0;
        }

        .loading-spinner {
            display: inline-block;
            width: 1rem;
            height: 1rem;
            border: 2px solid var(--pico-muted-border-color);
            border-top-color: #6b8dd6;
            border-radius: 50%;
            animation: spin 0.6s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .child-nodes {
            margin-top: 0.75rem;
        }

        @media (max-width: 768px) {
            .model-selectors {
                grid-template-columns: 1fr;
            }

            .api-key-section {
                flex-direction: column;
            }

            .api-key-section input,
            .api-key-section button {
                width: 100%;
            }

            .header-controls {
                flex-direction: column;
                align-items: flex-start;
            }

            .expand-btn {
                width: 1.85rem;
                height: 1.85rem;
                font-size: 0.85rem;
            }

            .node-info h3 {
                font-size: 0.9rem;
            }

            .expansion-card {
                padding: 0.5rem;
            }

            .tab-btn {
                padding: 0.4rem 0.6rem;
                font-size: 0.8rem;
            }
        }

        .expand-btn:focus {
            outline: 2px solid #6b8dd6;
            outline-offset: 2px;
        }

        .tag-btn {
            background-color: var(--pico-card-background-color);
            border: 1px solid var(--pico-muted-border-color);
            color: var(--pico-muted-color);
            transition: all 0.2s;
        }

        .tag-btn:hover {
            background-color: rgba(107, 141, 214, 0.1);
            border-color: #6b8dd6;
            color: #6b8dd6;
        }

        .tag-btn.active {
            background-color: #6b8dd6;
            border-color: #6b8dd6;
            color: white;
        }

        .loading-state {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            padding: 2rem 1rem;
            color: #6b8dd6;
            font-weight: 500;
        }

        .loading-dot {
            width: 0.5rem;
            height: 0.5rem;
            border-radius: 50%;
            background-color: #6b8dd6;
            animation: pulse 1.4s infinite;
        }

        .loading-dot:nth-child(2) {
            animation-delay: 0.2s;
        }

        .loading-dot:nth-child(3) {
            animation-delay: 0.4s;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 0.3;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1);
            }
        }
    </style>
</head>
<body>
    <main class="container">
        <p style="margin-bottom: 1rem;"><a href="index.html" class="back-link">← Back to Tools</a></p>
        <hgroup>
            <h1>AI Landscape Explorer</h1>
            <p>Interactive exploration of AI development tools and concepts with AI-generated insights</p>
        </hgroup>

        <div id="apiKeySection">
            <div class="api-key-section">
                <input
                    type="password"
                    id="apiKeyInput"
                    placeholder="OpenRouter API key..."
                    aria-label="OpenRouter API key"
                >
                <button onclick="saveApiKey()">Save Key</button>
            </div>
        </div>

        <div id="apiKeyStatus" style="display: none;">
            <div class="api-key-status">API Key Active</div>
            <button onclick="clearApiKey()" style="margin-bottom: 1rem;">Clear Key</button>
        </div>

        <div id="modelSelectors" style="display: none;">
            <details>
                <summary style="cursor: pointer; font-weight: 600; padding: 0.35rem; list-style-type: disclosure-closed;">Model Selection</summary>
                <div style="padding: 0.5rem 0;">
                    <div style="margin-bottom: 0.5rem;">
                        <input
                            type="text"
                            id="modelSearch"
                            placeholder="Search..."
                            oninput="filterModels()"
                            style="margin: 0; font-size: 0.85rem; padding: 0.3rem;"
                        >
                    </div>

                    <div style="margin-bottom: 0.5rem;">
                        <div id="modelTags" style="display: flex; flex-wrap: wrap; gap: 0.25rem;"></div>
                    </div>

                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 0.5rem;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 0.25rem; font-size: 0.85rem;">Primary</label>
                            <div id="primaryModelList" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--pico-muted-border-color); border-radius: var(--pico-border-radius); padding: 0.35rem; font-size: 0.8rem;"></div>
                        </div>

                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 0.25rem; font-size: 0.85rem;">Secondary</label>
                            <div id="secondaryModelList" style="max-height: 150px; overflow-y: auto; border: 1px solid var(--pico-muted-border-color); border-radius: var(--pico-border-radius); padding: 0.35rem; font-size: 0.8rem;"></div>
                        </div>
                    </div>
                </div>
            </details>
        </div>

        <div id="controls" style="display: none;">
            <div class="header-controls">
                <div class="toggle-group">
                    <input
                        type="checkbox"
                        id="webSearchToggle"
                        onchange="saveWebSearchPreference()"
                        checked
                        aria-label="Enable web search"
                    >
                    <label for="webSearchToggle">Enable web search</label>
                </div>
                <button onclick="clearAllCache()">Clear Cache</button>
            </div>
        </div>

        <div id="budgetDisplay" style="display: none;">
            <details class="budget-display">
                <summary id="budgetSummary">Budget: $0.00 (0 searches)</summary>
                <div class="budget-details">
                    <p>Tokens: <strong id="tokensUsed">0</strong></p>
                    <p>Searches: <strong id="searchesCount">0</strong></p>
                    <p>Cost: <strong id="estimatedCost">$0.00</strong></p>
                </div>
            </details>
        </div>

        <details class="setup-section">
            <summary>Setup Instructions</summary>
            <div class="setup-content">
                <p><strong>Getting your OpenRouter API key:</strong></p>
                <ol>
                    <li>Visit <a href="https://openrouter.ai/" target="_blank" rel="noopener">openrouter.ai</a></li>
                    <li>Create an account or sign in</li>
                    <li>Go to your profile settings</li>
                    <li>Copy your API key</li>
                    <li>Paste it above and click "Save Key"</li>
                </ol>
                <p><strong>How it works:</strong></p>
                <ul>
                    <li>Your API key is stored in your browser's session storage (cleared when you close the tab)</li>
                    <li>Cached responses are stored locally so you can view them without an API key</li>
                    <li>All processing happens in your browser</li>
                    <li>Click topics to expand and read AI-generated overviews</li>
                    <li>Toggle web search to get current information with citations</li>
                    <li>Use "Second Opinion" to compare responses from different models</li>
                </ul>
            </div>
        </details>

        <div id="tree" role="tree"></div>

        <p style="margin-top: 1rem;"><a href="index.html" class="back-link">← Back to Tools</a></p>
    </main>

    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>

    <script>
        // Configure marked for proper link rendering
        marked.setOptions({
            breaks: true,
            gfm: true,
            pedantic: false
        });

        const markedRenderer = new marked.Renderer();
        markedRenderer.link = ({ href, title, text }) => {
            return `<a href="${href}" target="_blank" rel="noopener noreferrer" title="${title || ''}">${text}</a>`;
        };
        marked.setOptions({ renderer: markedRenderer });
    </script>

    <script>
        // ==================== STATE ====================
        const state = {
            skeleton: null,
            expandedNodes: new Set(),
            apiKey: null,
            allModels: [],
            filteredModels: [],
            selectedTags: new Set(),
            budget: {
                totalTokensUsed: 0,
                totalSearches: 0,
                estimatedCost: 0.0
            },
            modelPricing: {},
            modelLimits: {},
            defaultLimits: {
                contextWindow: 8000,
                maxOutput: 2000
            },
            webSearchEnabled: true,
            primaryModel: 'anthropic/claude-sonnet-4',
            secondOpinionModel: 'openai/gpt-4o',
            prompts: {}
        };

        // ==================== INITIALIZATION ====================
        async function initializeApp() {
            // Load prompts
            await loadPrompts();

            // Load skeleton
            try {
                const response = await fetch('skeleton.yaml');
                const yaml = await response.text();
                state.skeleton = jsyaml.load(yaml);
                // Generate IDs for all nodes
                assignNodeIds(state.skeleton);
            } catch (error) {
                console.error('Failed to load skeleton:', error);
                state.skeleton = createFallbackSkeleton();
                assignNodeIds(state.skeleton);
            }

            // Load from storage
            loadApiKey();
            loadPreferences();
            loadBudget();

            // Render tree
            renderTree();

            // Initialize models if key exists
            if (state.apiKey) {
                showApiKeyStatus();
                await fetchAndPopulateModels();
            } else {
                showApiKeyInput();
            }
        }

        function createFallbackSkeleton() {
            return {
                name: "AI Development Landscape",
                summary: "A comprehensive overview of AI tools and concepts",
                children: []
            };
        }

        function assignNodeIds(node, parentId = '') {
            // Generate ID based on node name
            if (!node.id) {
                const nameId = node.name ? node.name.toLowerCase().replace(/[^a-z0-9]+/g, '-') : 'node';
                node.id = parentId ? `${parentId}-${nameId}` : nameId;
            }

            // Recursively assign IDs to children
            if (node.children && Array.isArray(node.children)) {
                node.children.forEach(child => {
                    assignNodeIds(child, node.id);
                });
            }
        }

        async function loadPrompts() {
            const promptFiles = ['node-overview', 'second-opinion', 'system-web-search'];
            const PROMPT_CACHE_TTL = 6 * 60 * 60 * 1000; // 6 hours

            for (const filename of promptFiles) {
                const cacheKey = `ai-landscape-prompt-${filename}`;
                const cached = localStorage.getItem(cacheKey);

                // Check if cache is still valid
                if (cached) {
                    try {
                        const entry = JSON.parse(cached);
                        if (Date.now() - entry.timestamp < PROMPT_CACHE_TTL) {
                            state.prompts[filename] = entry.content;
                            continue;
                        }
                    } catch (e) {
                        // Invalid cache, ignore and fetch fresh
                    }
                }

                // Fetch fresh prompt
                try {
                    const response = await fetch(`prompts/ai-landscape-explorer/${filename}.txt`);
                    if (response.ok) {
                        const content = await response.text();
                        state.prompts[filename] = content;

                        // Cache it
                        localStorage.setItem(cacheKey, JSON.stringify({
                            content,
                            timestamp: Date.now()
                        }));
                    } else {
                        console.warn(`Failed to load prompt: ${filename}`);
                    }
                } catch (error) {
                    console.warn(`Error loading prompt ${filename}:`, error);
                }
            }
        }

        function loadApiKey() {
            state.apiKey = sessionStorage.getItem('ai-landscape-apikey');
        }

        function loadPreferences() {
            const prefs = localStorage.getItem('ai-landscape-preferences');
            if (prefs) {
                const parsed = JSON.parse(prefs);
                state.primaryModel = parsed.primaryModel || state.primaryModel;
                state.secondOpinionModel = parsed.secondOpinionModel || state.secondOpinionModel;
                state.webSearchEnabled = parsed.enableWebSearch !== false;
                document.getElementById('webSearchToggle').checked = state.webSearchEnabled;
            }
        }

        function loadBudget() {
            const budget = localStorage.getItem('ai-landscape-budget');
            if (budget) {
                state.budget = JSON.parse(budget);
            }
            updateBudgetDisplay();
        }

        // ==================== API KEY MANAGEMENT ====================
        async function saveApiKey() {
            const key = document.getElementById('apiKeyInput').value.trim();
            if (!key) {
                showError('Please enter an API key');
                return;
            }

            state.apiKey = key;
            sessionStorage.setItem('ai-landscape-apikey', key);

            try {
                await fetchAndPopulateModels();
                showApiKeyStatus();
                showSuccess('API key saved successfully!');
                document.getElementById('apiKeyInput').value = '';
            } catch (error) {
                showError('Invalid API key or network error: ' + error.message);
                state.apiKey = null;
                sessionStorage.removeItem('ai-landscape-apikey');
            }
        }

        function clearApiKey() {
            state.apiKey = null;
            sessionStorage.removeItem('ai-landscape-apikey');
            showApiKeyInput();
            renderTree();
        }

        function showApiKeyInput() {
            document.getElementById('apiKeySection').style.display = 'block';
            document.getElementById('apiKeyStatus').style.display = 'none';
            document.getElementById('modelSelectors').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            document.getElementById('budgetDisplay').style.display = 'none';
        }

        function showApiKeyStatus() {
            document.getElementById('apiKeySection').style.display = 'none';
            document.getElementById('apiKeyStatus').style.display = 'block';
            document.getElementById('modelSelectors').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('budgetDisplay').style.display = 'block';
        }

        // ==================== MODEL MANAGEMENT ====================
        async function fetchAndPopulateModels() {
            const response = await fetch('https://openrouter.ai/api/v1/models', {
                headers: {
                    'Authorization': `Bearer ${state.apiKey}`
                }
            });

            if (!response.ok) {
                throw new Error(`API error: ${response.status}`);
            }

            const data = await response.json();
            const models = data.data || [];

            // Store model pricing and limits
            models.forEach(model => {
                const contextWindow = model.context_length || 8000;
                const isFree = parseFloat(model.pricing?.prompt) === 0 && parseFloat(model.pricing?.completion) === 0;

                state.modelPricing[model.id] = {
                    prompt: parseFloat(model.pricing?.prompt) || 0,
                    completion: parseFloat(model.pricing?.completion) || 0,
                    supportsTools: checkToolSupport(model)
                };

                state.modelLimits[model.id] = {
                    contextWindow: contextWindow,
                    maxOutput: isFree ? Math.min(2000, contextWindow * 0.25) : Math.min(4000, contextWindow * 0.5)
                };
            });

            // Store all models for filtering
            state.allModels = models;

            renderModelSearch();
        }

        function checkToolSupport(model) {
            const modelStr = JSON.stringify(model);
            return modelStr.includes('web_search') || modelStr.includes('tool');
        }

        function extractTags(model) {
            const tags = new Set();
            if (model.architecture?.modality) {
                tags.add(model.architecture.modality.split('->')[0]?.trim());
            }
            if (model.architecture?.input_modalities) {
                model.architecture.input_modalities.forEach(m => tags.add(m));
            }
            if (state.modelPricing[model.id]?.supportsTools) {
                tags.add('web-search');
            }
            if (state.modelPricing[model.id]?.prompt === 0 && state.modelPricing[model.id]?.completion === 0) {
                tags.add('free-model');
            }
            return Array.from(tags);
        }

        function renderModelSearch() {
            // Extract all unique tags from models
            const allTags = new Set();
            state.allModels.forEach(model => {
                extractTags(model).forEach(tag => allTags.add(tag));
            });

            // Render tag buttons
            const tagsContainer = document.getElementById('modelTags');
            tagsContainer.innerHTML = '';
            Array.from(allTags).sort().forEach(tag => {
                const btn = document.createElement('button');
                btn.style.padding = '0.25rem 0.5rem';
                btn.style.fontSize = '0.75rem';
                btn.style.margin = '0';
                btn.style.whiteSpace = 'nowrap';
                btn.textContent = tag;
                btn.className = state.selectedTags.has(tag) ? 'tag-btn active' : 'tag-btn';
                btn.onclick = () => toggleTag(tag);
                tagsContainer.appendChild(btn);
            });

            // Render models
            filterModels();
        }

        function toggleTag(tag) {
            if (state.selectedTags.has(tag)) {
                state.selectedTags.delete(tag);
            } else {
                state.selectedTags.add(tag);
            }
            renderModelSearch();
        }

        function filterModels() {
            const searchText = document.getElementById('modelSearch').value.toLowerCase();
            let filtered = state.allModels;

            // Filter by search text
            if (searchText) {
                filtered = filtered.filter(m => m.id.toLowerCase().includes(searchText) || m.name?.toLowerCase().includes(searchText));
            }

            // Filter by tags
            if (state.selectedTags.size > 0) {
                filtered = filtered.filter(model => {
                    const modelTags = new Set(extractTags(model));
                    return Array.from(state.selectedTags).some(tag => modelTags.has(tag));
                });
            }

            state.filteredModels = filtered;
            renderModelLists();
        }

        function renderModelLists() {
            const primaryList = document.getElementById('primaryModelList');
            const secondaryList = document.getElementById('secondaryModelList');

            primaryList.innerHTML = '';
            secondaryList.innerHTML = '';

            state.filteredModels.forEach(model => {
                const pricing = state.modelPricing[model.id];
                const prompt = ((parseFloat(pricing?.prompt) || 0) * 1_000_000).toFixed(2);
                const completion = ((parseFloat(pricing?.completion) || 0) * 1_000_000).toFixed(2);
                const limits = state.modelLimits[model.id];
                const limitText = limits ? `${(limits.contextWindow/1000).toFixed(0)}k ctx / ${(limits.maxOutput/1000).toFixed(1)}k out` : '';

                // Primary model
                const primaryLabel = document.createElement('div');
                primaryLabel.style.padding = '0.35rem';
                primaryLabel.style.borderBottom = '1px solid var(--pico-muted-border-color)';
                primaryLabel.style.cursor = 'pointer';
                primaryLabel.style.display = 'flex';
                primaryLabel.style.justifyContent = 'space-between';
                primaryLabel.style.alignItems = 'center';
                primaryLabel.style.gap = '0.25rem';
                primaryLabel.onmouseover = () => primaryLabel.style.background = 'rgba(107, 141, 214, 0.05)';
                primaryLabel.onmouseout = () => primaryLabel.style.background = 'none';

                const primaryText = document.createElement('div');
                primaryText.style.fontSize = '0.8rem';
                primaryText.style.lineHeight = '1.2';
                primaryText.innerHTML = `<strong style="display: block; font-size: 0.75rem;">${model.id.split('/')[1]}</strong><small style="color: var(--pico-muted-color); display: block;">$${prompt}/$${completion}</small>${limitText ? `<small style="color: var(--pico-muted-color); display: block;">${limitText}</small>` : ''}`;
                primaryLabel.appendChild(primaryText);

                const primaryRadio = document.createElement('input');
                primaryRadio.type = 'radio';
                primaryRadio.name = 'primary-model';
                primaryRadio.checked = state.primaryModel === model.id;
                primaryRadio.onchange = () => selectPrimaryModel(model.id);
                primaryLabel.appendChild(primaryRadio);

                primaryList.appendChild(primaryLabel);

                // Secondary model
                const secondaryLabel = document.createElement('div');
                secondaryLabel.style.padding = '0.35rem';
                secondaryLabel.style.borderBottom = '1px solid var(--pico-muted-border-color)';
                secondaryLabel.style.cursor = 'pointer';
                secondaryLabel.style.display = 'flex';
                secondaryLabel.style.justifyContent = 'space-between';
                secondaryLabel.style.alignItems = 'center';
                secondaryLabel.style.gap = '0.25rem';
                secondaryLabel.onmouseover = () => secondaryLabel.style.background = 'rgba(107, 141, 214, 0.05)';
                secondaryLabel.onmouseout = () => secondaryLabel.style.background = 'none';

                const secondaryText = document.createElement('div');
                secondaryText.style.fontSize = '0.8rem';
                secondaryText.style.lineHeight = '1.2';
                secondaryText.innerHTML = `<strong style="display: block; font-size: 0.75rem;">${model.id.split('/')[1]}</strong><small style="color: var(--pico-muted-color); display: block;">$${prompt}/$${completion}</small>${limitText ? `<small style="color: var(--pico-muted-color); display: block;">${limitText}</small>` : ''}`;
                secondaryLabel.appendChild(secondaryText);

                const secondaryRadio = document.createElement('input');
                secondaryRadio.type = 'radio';
                secondaryRadio.name = 'secondary-model';
                secondaryRadio.checked = state.secondOpinionModel === model.id;
                secondaryRadio.onchange = () => selectSecondaryModel(model.id);
                secondaryLabel.appendChild(secondaryRadio);

                secondaryList.appendChild(secondaryLabel);
            });
        }

        function selectPrimaryModel(modelId) {
            state.primaryModel = modelId;
            savePreferences();
            renderModelLists();
        }

        function selectSecondaryModel(modelId) {
            state.secondOpinionModel = modelId;
            savePreferences();
            renderModelLists();
        }

        function saveWebSearchPreference() {
            state.webSearchEnabled = document.getElementById('webSearchToggle').checked;
            savePreferences();
        }

        function savePreferences() {
            const prefs = {
                primaryModel: state.primaryModel,
                secondOpinionModel: state.secondOpinionModel,
                enableWebSearch: state.webSearchEnabled
            };
            localStorage.setItem('ai-landscape-preferences', JSON.stringify(prefs));
        }


        // ==================== CACHE MANAGEMENT ====================
        function cacheGet(nodeId) {
            const cached = localStorage.getItem(`ai-landscape-${nodeId}`);
            if (!cached) return null;

            try {
                const entry = JSON.parse(cached);
                const expiry = entry.expiry || (entry.timestamp + 30 * 24 * 60 * 60 * 1000);

                if (Date.now() > expiry) {
                    localStorage.removeItem(`ai-landscape-${nodeId}`);
                    return null;
                }

                return entry.value || entry; // Support v1 format
            } catch {
                return null;
            }
        }

        function cacheSet(nodeId, value) {
            const entry = {
                cacheVersion: 2,
                value,
                timestamp: Date.now(),
                expiry: Date.now() + 30 * 24 * 60 * 60 * 1000
            };
            localStorage.setItem(`ai-landscape-${nodeId}`, JSON.stringify(entry));
        }

        function clearAllCache() {
            if (!confirm('Clear all cached content? You can still use cached items from this session.')) return;

            const keys = Object.keys(localStorage);
            keys.forEach(key => {
                if (key.startsWith('ai-landscape-') && !key.includes('preferences') && !key.includes('budget') && !key.includes('apikey')) {
                    localStorage.removeItem(key);
                }
            });

            state.expandedNodes.clear();
            renderTree();
            showSuccess('Cache cleared');
        }

        // ==================== TREE RENDERING ====================
        function renderTree() {
            const treeEl = document.getElementById('tree');
            if (!state.skeleton) {
                treeEl.innerHTML = '<p>Loading tree...</p>';
                return;
            }

            treeEl.innerHTML = '';
            renderNode(state.skeleton, treeEl, 0);
        }

        function renderNode(node, parent, level) {
            const isMobile = window.innerWidth <= 768;
            const nodeEl = document.createElement('div');
            nodeEl.className = 'tree-node';
            nodeEl.setAttribute('data-id', node.id || 'root');
            nodeEl.setAttribute('data-level', level);
            nodeEl.setAttribute('role', 'treeitem');

            // Header
            const headerEl = document.createElement('div');
            headerEl.className = 'node-header';

            const isExpanded = state.expandedNodes.has(node.id);
            const hasCache = node.id && cacheGet(node.id) !== null;
            const hasApiKey = state.apiKey !== null;
            const canExpand = node.children && node.children.length > 0;
            const canFetchContent = hasCache || hasApiKey;

            // Expand button
            const btnEl = document.createElement('button');
            btnEl.className = 'expand-btn';
            btnEl.setAttribute('aria-expanded', isExpanded);
            btnEl.setAttribute('aria-label', `Expand ${node.name}`);
            btnEl.textContent = isExpanded ? '−' : '+';
            btnEl.disabled = !canExpand && !canFetchContent;
            btnEl.title = !canExpand && !canFetchContent ? 'No subcategories or API key' :
                          !canExpand ? 'No subcategories (click for AI overview)' : '';
            btnEl.onclick = (e) => {
                e.stopPropagation();
                toggleNode(node.id, btnEl);
            };
            headerEl.appendChild(btnEl);

            // Info
            const infoEl = document.createElement('div');
            infoEl.className = 'node-info';
            const titleEl = document.createElement('h2');
            titleEl.textContent = node.name || 'Unnamed';
            const summaryEl = document.createElement('p');
            summaryEl.textContent = node.summary || '';
            infoEl.appendChild(titleEl);
            infoEl.appendChild(summaryEl);
            headerEl.appendChild(infoEl);

            nodeEl.appendChild(headerEl);

            // Content
            const contentEl = document.createElement('div');
            contentEl.className = 'node-content' + (isExpanded ? '' : ' hidden');

            if (node.id && node.children && node.children.length > 0) {
                const childrenEl = document.createElement('div');
                childrenEl.className = 'child-nodes';

                node.children.forEach(child => {
                    renderNode(child, childrenEl, level + 1);
                });

                contentEl.appendChild(childrenEl);
            }

            if (node.id && (canExpand || canFetchContent)) {
                const cardEl = document.createElement('div');
                cardEl.className = 'expansion-card';
                cardEl.id = `card-${node.id}`;
                cardEl.style.display = isExpanded ? 'block' : 'none';

                const headerDiv = document.createElement('div');
                headerDiv.className = 'card-header';
                headerDiv.innerHTML = '<div class="loading-state">Thinking<div class="loading-dot"></div><div class="loading-dot"></div><div class="loading-dot"></div></div>';
                cardEl.appendChild(headerDiv);

                if (isExpanded && hasCache) {
                    renderCachedContent(node.id, cardEl);
                }

                contentEl.insertBefore(cardEl, contentEl.firstChild);
            }

            nodeEl.appendChild(contentEl);
            parent.appendChild(nodeEl);
        }

        function toggleNode(nodeId, btnEl) {
            const isExpanded = state.expandedNodes.has(nodeId);

            if (isExpanded) {
                state.expandedNodes.delete(nodeId);
                const contentEl = document.querySelector(`[data-id="${nodeId}"] .node-content`);
                if (contentEl) contentEl.classList.add('hidden');
                const cardEl = document.getElementById(`card-${nodeId}`);
                if (cardEl) cardEl.style.display = 'none';
                btnEl.textContent = '+';
                btnEl.setAttribute('aria-expanded', 'false');
            } else {
                state.expandedNodes.add(nodeId);
                const contentEl = document.querySelector(`[data-id="${nodeId}"] .node-content`);
                if (contentEl) contentEl.classList.remove('hidden');
                const cardEl = document.getElementById(`card-${nodeId}`);
                if (cardEl) {
                    cardEl.style.display = 'block';

                    const cached = cacheGet(nodeId);
                    // Only use cached if it's a successful response (has content, not an error)
                    if (cached && cached.content && !cached.isError) {
                        renderCachedContent(nodeId, cardEl);
                    } else if (state.apiKey) {
                        // Clear any previous content (errors)
                        cardEl.innerHTML = '';
                        fetchNodeContent(nodeId, cardEl);
                    } else {
                        cardEl.innerHTML = '<p class="error-message">API key required - please add your key above</p>';
                    }
                }
                btnEl.textContent = '−';
                btnEl.setAttribute('aria-expanded', 'true');
            }
        }

        // ==================== CONTENT FETCHING ====================
        async function fetchNodeContent(nodeId, cardEl) {
            const node = findNode(state.skeleton, nodeId);
            if (!node) return;

            const headerDiv = cardEl.querySelector('.card-header');
            if (!headerDiv) {
                const h = document.createElement('div');
                h.className = 'card-header';
                h.innerHTML = '<div class="loading-spinner"></div> Loading...';
                cardEl.insertBefore(h, cardEl.firstChild);
            }

            try {
                // Estimate tokens and warn if approaching limit
                const modelLimits = state.modelLimits[state.primaryModel] || state.defaultLimits;
                const estimatedPrompt = estimatePromptTokens(node);
                const estimatedTotal = estimatedPrompt + modelLimits.maxOutput;

                if (estimatedTotal > modelLimits.contextWindow * 0.9) {
                    console.warn(`Token usage approaching limit: ${estimatedTotal}/${modelLimits.contextWindow}`);
                }

                const prompt = buildNodePrompt(node);
                const useWebSearch = state.webSearchEnabled;
                const modelInfo = state.modelPricing[state.primaryModel];
                const supportsTools = modelInfo?.supportsTools;

                let result;
                if (useWebSearch && supportsTools) {
                    result = await callOpenRouterWithSearch(state.primaryModel, prompt);
                } else {
                    result = await callOpenRouterChat(state.primaryModel, prompt);
                }

                // Cache the result
                cacheSet(nodeId, result);

                // Render content
                renderExpandedContent(nodeId, cardEl, result, node);

                // Update budget
                updateBudget(result.tokenUsage, result.searchesPerformed.length, state.modelPricing[state.primaryModel]);

            } catch (error) {
                cardEl.innerHTML = `<p class="error-message">Error: ${error.message}</p>`;
            }
        }

        function findNode(skeleton, nodeId) {
            if (skeleton.id === nodeId) return skeleton;
            if (!skeleton.children) return null;

            for (let child of skeleton.children) {
                const found = findNode(child, nodeId);
                if (found) return found;
            }
            return null;
        }

        function buildNodePrompt(node) {
            if (!state.prompts['node-overview']) {
                console.warn('Node overview prompt not loaded');
                return '';
            }
            const isFreeModel = state.modelPricing[state.primaryModel]?.prompt === 0;
            const summaryLimit = isFreeModel ? 200 : 500;
            const summary = (node.summary || '').substring(0, summaryLimit);
            const prompt = state.prompts['node-overview']
                .replace('{nodeName}', node.name || '')
                .replace('{nodeSummary}', summary);
            const estimatedTokens = estimateTokens(prompt);
            console.log('Built prompt length:', prompt.length, 'chars (~', estimatedTokens, 'tokens)');
            return prompt;
        }

        // ==================== TOKEN ESTIMATION ====================
        function estimateTokens(text) {
            // Rough estimation: 1 token ≈ 4 characters for English
            return Math.ceil(text.length / 4);
        }

        function estimatePromptTokens(node) {
            const prompt = buildNodePrompt(node);
            return estimateTokens(prompt);
        }

        function estimateTotalTokens(node, maxOutput) {
            return estimatePromptTokens(node) + maxOutput;
        }

        async function callOpenRouterWithSearch(model, prompt) {
            // Note: Using standard chat completions endpoint with web_search tools
            // Web search capability depends on model support
            const systemMsg = state.prompts['system-web-search'] || 'Provide accurate, current information. When relevant, search the web for current information. Be concise.';
            console.log('Model:', model);
            console.log('System message length:', systemMsg.length);
            console.log('User prompt length:', prompt.length);
            console.log('Web search enabled for model:', model);

            // Calculate token limits
            const modelLimits = state.modelLimits[model] || state.defaultLimits;
            const isFreeModel = state.modelPricing[model]?.prompt === 0;
            const promptTokens = estimateTokens(prompt) + estimateTokens(systemMsg);
            const availableOutput = Math.min(
                modelLimits.maxOutput,
                modelLimits.contextWindow - promptTokens - 100
            );
            const maxTokens = isFreeModel ? Math.min(availableOutput, 1500) : availableOutput;

            const body = {
                model,
                max_tokens: maxTokens,
                messages: [
                    {
                        role: 'system',
                        content: systemMsg
                    },
                    {
                        role: 'user',
                        content: prompt
                    }
                ],
                tools: [
                    {
                        type: 'function',
                        function: {
                            name: 'web_search',
                            description: 'Search the web for current information',
                            parameters: {
                                type: 'object',
                                properties: {
                                    query: {
                                        type: 'string',
                                        description: 'The search query'
                                    }
                                },
                                required: ['query']
                            }
                        }
                    }
                ]
            };

            console.log('Token limits - prompt:', promptTokens, 'max_output:', maxTokens, 'context_window:', modelLimits.contextWindow);
            console.log('Total body size:', JSON.stringify(body).length);
            console.log('Full request body with web search tools:', JSON.stringify(body, null, 2));

            const response = await fetchWithRetry(() =>
                fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${state.apiKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'AI Landscape Explorer',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                })
            );

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMsg = errorData.error?.message || errorData.message || '';

                // Detect token limit errors
                if (response.status === 400 &&
                    (errorMsg.toLowerCase().includes('token') || errorMsg.toLowerCase().includes('context') || errorMsg.toLowerCase().includes('length'))) {
                    throw new Error('Token limit exceeded. Try a model with a larger context window or refresh to get a shorter response.');
                }

                // Detect rate limit errors
                if (response.status === 429) {
                    throw new Error('Rate limit reached. Please wait a moment before trying again.');
                }

                throw new Error(`API error: ${response.status} - ${errorMsg || 'Unknown error'}`);
            }

            const data = await response.json();
            const message = data.choices[0].message;

            // Parse tool use and extract search queries if present
            let searchesPerformed = [];
            let textContent = message.content;

            if (Array.isArray(message.content)) {
                // Handle structured content blocks
                const textBlocks = [];
                message.content.forEach(block => {
                    if (block.type === 'text') {
                        textBlocks.push(block.text);
                    } else if (block.type === 'tool_use' && block.name === 'web_search') {
                        searchesPerformed.push(block.input?.query || '');
                        console.log('Captured web search:', block.input?.query);
                    }
                });
                textContent = textBlocks.join('\n\n');
            } else if (typeof message.content === 'string') {
                // String content - check for tool use markers
                textContent = message.content;
            }

            console.log('Web search response - searches:', searchesPerformed.length, 'searches:', searchesPerformed);

            return {
                content: textContent,
                searchesPerformed,
                sources: [],
                tokenUsage: data.usage,
                model
            };
        }

        async function callOpenRouterChat(model, prompt) {
            console.log('Chat prompt length:', prompt.length);

            // Calculate token limits
            const modelLimits = state.modelLimits[model] || state.defaultLimits;
            const isFreeModel = state.modelPricing[model]?.prompt === 0;
            const promptTokens = estimateTokens(prompt);
            const availableOutput = Math.min(
                modelLimits.maxOutput,
                modelLimits.contextWindow - promptTokens - 100
            );
            const maxTokens = isFreeModel ? Math.min(availableOutput, 1500) : availableOutput;

            const body = {
                model,
                max_tokens: maxTokens,
                messages: [
                    {
                        role: 'user',
                        content: prompt
                    }
                ]
            };

            console.log('Token limits - prompt:', promptTokens, 'max_output:', maxTokens, 'context_window:', modelLimits.contextWindow);
            console.log('Total chat body size:', JSON.stringify(body).length);

            const response = await fetchWithRetry(() =>
                fetch('https://openrouter.ai/api/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${state.apiKey}`,
                        'HTTP-Referer': window.location.href,
                        'X-Title': 'AI Landscape Explorer',
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(body)
                })
            );

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMsg = errorData.error?.message || errorData.message || '';

                // Detect token limit errors
                if (response.status === 400 &&
                    (errorMsg.toLowerCase().includes('token') || errorMsg.toLowerCase().includes('context') || errorMsg.toLowerCase().includes('length'))) {
                    throw new Error('Token limit exceeded. Try a model with a larger context window or refresh to get a shorter response.');
                }

                // Detect rate limit errors
                if (response.status === 429) {
                    throw new Error('Rate limit reached. Please wait a moment before trying again.');
                }

                throw new Error(`API error: ${response.status} - ${errorMsg || 'Unknown error'}`);
            }

            const data = await response.json();
            return {
                content: data.choices[0].message.content,
                searchesPerformed: [],
                sources: [],
                tokenUsage: data.usage,
                model
            };
        }

        function parseSearchResponse(response, model) {
            const content = response.choices[0].message.content;

            const textBlocks = [];
            const searches = [];
            const sources = [];

            content.forEach(block => {
                if (block.type === 'text') {
                    textBlocks.push(block.text);
                } else if (block.type === 'tool_use' && block.name === 'web_search') {
                    searches.push(block.input.query);
                } else if (block.type === 'tool_result' && Array.isArray(block.content)) {
                    block.content.forEach(result => {
                        if (result.url && result.title) {
                            const domain = new URL(result.url).hostname;
                            const highQuality = ['.edu', '.gov', 'arxiv.org', 'github.com'];
                            const quality = highQuality.some(hq => domain.includes(hq)) ? 'high' : 'medium';

                            sources.push({
                                url: result.url,
                                title: result.title,
                                relevantExcerpt: result.snippet || '',
                                quality
                            });
                        }
                    });
                }
            });

            return {
                content: textBlocks.join('\n\n'),
                searchesPerformed: searches,
                sources,
                tokenUsage: response.usage,
                model
            };
        }

        async function fetchWithRetry(fetchFn, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    return await fetchFn();
                } catch (error) {
                    if (attempt === maxRetries) throw error;
                    if (error.status && error.status >= 400 && error.status < 500) throw error;

                    const delay = Math.pow(2, attempt - 1) * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // ==================== CONTENT RENDERING ====================
        function renderCachedContent(nodeId, cardEl) {
            const cached = cacheGet(nodeId);
            const node = findNode(state.skeleton, nodeId);
            if (!cached || !node) return;

            renderExpandedContent(nodeId, cardEl, cached, node);
        }

        function renderExpandedContent(nodeId, cardEl, content, node) {
            const timeNow = Date.now();
            const ageMs = timeNow - (content.timestamp || timeNow);
            const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));

            const headerDiv = cardEl.querySelector('.card-header');
            let stalenessIndicator = '';
            if (ageDays > 20) {
                stalenessIndicator = `<span class="staleness-warning">Generated ${ageDays} days ago (age warning)</span>`;
            } else if (ageDays > 10) {
                stalenessIndicator = `<span>Generated ${ageDays} days ago</span>`;
            }

            let searchBadge = '';
            if (content.searchesPerformed && content.searchesPerformed.length > 0) {
                const count = content.searchesPerformed.length;
                const className = count >= 3 ? 'search green' : 'search';
                searchBadge = `<span class="badge ${className}">${count} search${count !== 1 ? 'es' : ''}</span>`;
            }

            const modelBadge = `<span class="badge model">${content.model?.split('/')[1] || 'unknown'}</span>`;

            headerDiv.innerHTML = `
                ${modelBadge}
                ${searchBadge}
                ${stalenessIndicator}
                <button class="refresh-btn" onclick="refreshNode('${nodeId}')" title="Refresh">Refresh</button>
            `;

            const article = document.createElement('article');
            article.innerHTML = marked.parse(content.content);
            cardEl.appendChild(article);

            if (content.sources && content.sources.length > 0) {
                const sourcesHTML = renderSources(content.sources);
                const sourcesEl = document.createElement('div');
                sourcesEl.innerHTML = sourcesHTML;
                cardEl.appendChild(sourcesEl);
            }

            if (state.apiKey) {
                const secondOpinionBtn = document.createElement('button');
                secondOpinionBtn.className = 'second-opinion-btn';
                secondOpinionBtn.textContent = 'Get Second Opinion';
                secondOpinionBtn.onclick = () => getSecondOpinion(nodeId, cardEl, node);
                cardEl.appendChild(secondOpinionBtn);
            }
        }

        function renderSources(sources) {
            const sourcesHTML = sources.map(source => {
                const badge = source.quality === 'high' ? '<span class="quality-badge">[High Quality]</span>' : '';
                const url = source.url;
                const title = escapeHtml(source.title);
                const excerpt = escapeHtml(source.relevantExcerpt || '');
                const domain = new URL(url).hostname;

                return `
                    <li class="source-item">
                        ${badge}<a href="${url}" target="_blank" rel="noopener noreferrer">${title}</a>
                        <p class="source-excerpt">${excerpt}</p>
                        <span class="source-domain">${domain}</span>
                    </li>
                `;
            }).join('');

            return `
                <details class="sources-section">
                    <summary>Sources (${sources.length})</summary>
                    <ul class="source-list">
                        ${sourcesHTML}
                    </ul>
                </details>
            `;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        async function refreshNode(nodeId) {
            const cardEl = document.getElementById(`card-${nodeId}`);
            if (!cardEl) return;

            cardEl.innerHTML = '<div class="card-header"><div class="loading-state">Refreshing<div class="loading-dot"></div><div class="loading-dot"></div><div class="loading-dot"></div></div></div>';
            localStorage.removeItem(`ai-landscape-${nodeId}`);
            await fetchNodeContent(nodeId, cardEl);
        }

        // ==================== SECOND OPINION ====================
        async function getSecondOpinion(nodeId, cardEl, node) {
            const cached = cacheGet(nodeId);
            if (!cached || !cached.secondOpinion) {
                const btn = cardEl.querySelector('.second-opinion-btn');
                if (btn) btn.textContent = 'Loading second opinion...';

                try {
                    const prompt = buildSecondOpinionPrompt(node, cached.content);
                    const useWebSearch = state.webSearchEnabled;
                    const modelInfo = state.modelPricing[state.secondOpinionModel];
                    const supportsTools = modelInfo?.supportsTools;

                    let result;
                    if (useWebSearch && supportsTools) {
                        result = await callOpenRouterWithSearch(state.secondOpinionModel, prompt);
                    } else {
                        result = await callOpenRouterChat(state.secondOpinionModel, prompt);
                    }

                    // Update cache
                    const updated = cacheGet(nodeId);
                    updated.secondOpinion = result;
                    cacheSet(nodeId, updated);

                    updateBudget(result.tokenUsage, result.searchesPerformed.length, state.modelPricing[state.secondOpinionModel]);

                    renderSecondOpinionUI(cardEl, cached, result);
                } catch (error) {
                    showError('Failed to get second opinion: ' + error.message);
                }
            } else {
                renderSecondOpinionUI(cardEl, cached, cached.secondOpinion);
            }
        }

        function buildSecondOpinionPrompt(node, firstContent) {
            if (!state.prompts['second-opinion']) {
                console.warn('Second opinion prompt not loaded');
                return '';
            }
            const preview = firstContent.substring(0, 500);
            return state.prompts['second-opinion']
                .replace('{nodeName}', node.name)
                .replace('{firstContentPreview}', preview);
        }

        function renderSecondOpinionUI(cardEl, cached, secondOpinion) {
            const existingTabs = cardEl.querySelector('.tabs');
            if (existingTabs) existingTabs.remove();

            const tabsHTML = `
                <div class="tabs">
                    <button class="tab-btn active" onclick="switchTab(event, 'primary')">
                        ${cached.model?.split('/')[1] || 'Primary'}${cached.searchesPerformed?.length ? ' (' + cached.searchesPerformed.length + ')' : ''}
                    </button>
                    <button class="tab-btn" onclick="switchTab(event, 'secondary')">
                        ${secondOpinion.model?.split('/')[1] || 'Secondary'}${secondOpinion.searchesPerformed?.length ? ' (' + secondOpinion.searchesPerformed.length + ')' : ''}
                    </button>
                </div>
                <div id="primary" class="tab-content active">
                    <article>${marked.parse(cached.content)}</article>
                    ${cached.sources?.length ? renderSources(cached.sources) : ''}
                </div>
                <div id="secondary" class="tab-content">
                    <article>${marked.parse(secondOpinion.content)}</article>
                    ${secondOpinion.sources?.length ? renderSources(secondOpinion.sources) : ''}
                </div>
            `;

            const secondOpinionBtn = cardEl.querySelector('.second-opinion-btn');
            if (secondOpinionBtn) secondOpinionBtn.remove();

            cardEl.insertAdjacentHTML('beforeend', tabsHTML);
        }

        function switchTab(event, tabId) {
            event.target.parentElement.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            event.target.parentElement.parentElement.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabId).classList.add('active');
        }

        // ==================== BUDGET TRACKING ====================
        function updateBudget(usage, searchCount, modelInfo) {
            if (!usage) return;

            const promptCost = (usage.prompt_tokens / 1_000_000) * (modelInfo?.prompt || 0);
            const completionCost = (usage.completion_tokens / 1_000_000) * (modelInfo?.completion || 0);
            const searchCost = searchCount * 0.02;
            const totalCost = promptCost + completionCost + searchCost;

            state.budget.totalTokensUsed += usage.total_tokens;
            state.budget.totalSearches += searchCount;
            state.budget.estimatedCost += totalCost;

            localStorage.setItem('ai-landscape-budget', JSON.stringify(state.budget));
            updateBudgetDisplay();
        }

        function updateBudgetDisplay() {
            const summary = document.getElementById('budgetSummary');
            const sessionTokenLimit = 50000;
            const percentUsed = (state.budget.totalTokensUsed / sessionTokenLimit) * 100;

            let warningIcon = '';
            if (percentUsed > 80) warningIcon = '⚠️ ';
            else if (percentUsed > 50) warningIcon = '⚡ ';

            if (summary) {
                summary.textContent = `${warningIcon}Budget: $${state.budget.estimatedCost.toFixed(2)} (${state.budget.totalTokensUsed.toLocaleString()} tokens)`;
            }

            document.getElementById('tokensUsed').textContent = `${state.budget.totalTokensUsed.toLocaleString()} / ${sessionTokenLimit.toLocaleString()}`;
            document.getElementById('searchesCount').textContent = state.budget.totalSearches;
            document.getElementById('estimatedCost').textContent = `$${state.budget.estimatedCost.toFixed(2)}`;
        }

        // ==================== UTILITY ====================
        function showError(message) {
            const container = document.getElementById('apiKeyStatus') || document.getElementById('apiKeySection');
            const el = document.createElement('div');
            el.className = 'error-message';
            el.textContent = message;
            container.insertAdjacentElement('afterend', el);
            setTimeout(() => el.remove(), 5000);
        }

        function showSuccess(message) {
            const container = document.getElementById('apiKeyStatus') || document.getElementById('apiKeySection');
            const el = document.createElement('div');
            el.className = 'success-message';
            el.textContent = message;
            container.insertAdjacentElement('afterend', el);
            setTimeout(() => el.remove(), 5000);
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', initializeApp);

        // Mobile default: collapse all nodes
        window.addEventListener('load', () => {
            const isMobile = window.innerWidth <= 768;
            if (isMobile && state.expandedNodes.size === 0) {
                state.expandedNodes.clear();
            }
        });
    </script>
</body>
</html>
