<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Editor</title>
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <link rel="stylesheet" href="common-styles.css">
    <style>
        .upload-area {
            border: 2px dashed var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 2rem 1.25rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #6b8dd6;
            background: rgba(107, 141, 214, 0.05);
        }

        .upload-area.drag-over {
            border-color: #6b8dd6;
            background: rgba(107, 141, 214, 0.1);
        }

        input[type="file"] {
            display: none;
        }

        #controls {
            display: none;
        }

        #controls.visible {
            display: block;
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
            align-items: center;
        }

        .toolbar button {
            flex: 0 1 auto;
        }

        .toolbar button.active {
            background-color: #4a6fa5;
            border-color: #4a6fa5;
        }

        .pdf-container {
            background: #f5f5f5;
            padding: 1rem;
            border-radius: var(--pico-border-radius);
            max-height: 70vh;
            overflow-y: auto;
            position: relative;
        }

        .pdf-page-wrapper {
            position: relative;
            margin-bottom: 1rem;
            background: white;
            display: inline-block;
            width: 100%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .pdf-page-canvas {
            display: block;
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
        }

        .fields-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .field-overlay {
            position: absolute;
            border: 2px solid #6b8dd6;
            background: rgba(107, 141, 214, 0.05);
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            transition: all 0.2s;
            pointer-events: auto;
        }

        .field-overlay:hover {
            border-color: #4a6fa5;
            background: rgba(107, 141, 214, 0.1);
        }

        .field-overlay.selected {
            border-color: #4a6fa5;
            border-width: 3px;
            background: rgba(107, 141, 214, 0.15);
            box-shadow: 0 0 0 1px rgba(107, 141, 214, 0.3);
        }

        .field-overlay input,
        .field-overlay select {
            width: 100%;
            height: 100%;
            border: none;
            background: none;
            padding: 0.2rem;
            font-size: 0.9rem;
            box-sizing: border-box;
        }

        .field-overlay input:focus,
        .field-overlay select:focus {
            outline: none;
        }

        .field-delete-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 24px;
            height: 24px;
            padding: 0;
            background: #dc3545;
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 0.75rem;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }

        .field-overlay.selected .field-delete-btn {
            display: flex;
        }

        .field-overlay.resizable::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: #6b8dd6;
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
            display: none;
        }

        .field-overlay.resizable.selected::after {
            display: block;
        }

        #status {
            display: none;
            margin-top: 1rem;
            padding: 1rem;
            border-radius: var(--pico-border-radius);
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        #status[aria-invalid="true"] {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        #status.visible {
            display: block;
        }

        .lasso-rect {
            position: absolute;
            border: 2px dashed #6b8dd6;
            background: rgba(107, 141, 214, 0.1);
            pointer-events: none;
            z-index: 999;
        }

        .snap-guide {
            position: absolute;
            pointer-events: none;
            z-index: 998;
        }

        .instructions {
            background: rgba(107, 141, 214, 0.05);
            border-left: 4px solid #6b8dd6;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.25rem;
        }

        .instructions h3 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .instructions ol {
            margin: 0;
            padding-left: 1.5rem;
        }

        .instructions li {
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body>
    <main class="container">
        <p style="margin-bottom: 1rem;"><a href="index.html" class="back-link">‚Üê Back to Tools</a></p>
        <hgroup>
            <h1>PDF Form Editor</h1>
            <p>Make static PDF forms editable by adding fillable fields</p>
        </hgroup>

        <article id="uploadSection">
            <div class="upload-area" id="uploadArea">
                <p>üìÑ Drop PDF here or click to upload</p>
                <p style="margin: 0; color: #999; font-size: 0.9rem;">Maximum file size: 50 MB</p>
                <input type="file" id="fileInput" accept=".pdf">
            </div>
        </article>

        <article id="controls">
            <div class="instructions">
                <h3>How to use:</h3>
                <ol>
                    <li>Click a field type button, then click and drag on the PDF to create a field</li>
                    <li>Shift+click to select multiple fields</li>
                    <li>Drag to move, use corner handle to resize text fields</li>
                    <li>Use alignment tools to arrange multiple selected fields</li>
                    <li>Copy/paste fields with Cmd/Ctrl+C and Cmd/Ctrl+V</li>
                    <li>Undo with Cmd/Ctrl+Z, Redo with Cmd/Ctrl+Shift+Z</li>
                    <li>Download your filled PDF when ready</li>
                </ol>
            </div>

            <div class="toolbar">
                <button id="addTextBtn" data-type="text">+ Text Field</button>
                <button id="addCheckboxBtn" data-type="checkbox">+ Checkbox</button>
                <button id="addRadioBtn" data-type="radio">+ Radio Button</button>
                <button id="addDropdownBtn" data-type="dropdown">+ Dropdown</button>
                <span style="flex: 0 0 1px; background: #ccc; height: 24px; margin: 0 0.25rem;"></span>

                <!-- Alignment toolbar (shown when 2+ fields selected) -->
                <div id="alignmentTools" style="display: none; display: flex; gap: 0.5rem;">
                    <button id="alignLeftBtn" title="Align left edges">‚á§ Left</button>
                    <button id="alignRightBtn" title="Align right edges">Right ‚á•</button>
                    <button id="alignTopBtn" title="Align top edges">‚áß Top</button>
                    <button id="alignBottomBtn" title="Align bottom edges">Bottom ‚á©</button>
                    <button id="distributeHBtn" title="Distribute horizontally">‚Üî Dist H</button>
                    <button id="distributeVBtn" title="Distribute vertically">‚Üï Dist V</button>
                </div>

                <span style="flex: 0 0 1px; background: #ccc; height: 24px; margin: 0 0.25rem;"></span>
                <button id="clearFieldsBtn" style="background-color: #dc3545; border-color: #dc3545;">Clear All</button>
                <button id="downloadBtn" style="background-color: #28a745; border-color: #28a745;">Download PDF</button>
            </div>

            <div id="status"></div>

            <div class="pdf-container" id="pdfContainer"></div>
        </article>

        <p style="margin-top:1rem"><a href="index.html" class="back-link">‚Üê Back to Tools</a></p>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script>
        // Setup PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB
        const PDF_SCALE = 1.5; // Scale factor for rendering PDFs

        // ==================== GLOBAL STATE ====================

        let state = {
            pdf: {
                doc: null,
                fileName: '',
                bytes: null
            },
            pages: [],
            currentPage: 0,
            mode: 'edit', // 'edit' or 'fill'
            activeTool: null, // 'text', 'checkbox', 'radio', 'signature'
            selectedFieldIds: [],
            dragState: null,
            settings: {
                snapToGrid: true,
                gridSize: 5,
                showGrid: false,
                snapToFields: true,
                snapThreshold: 5
            },
            history: {
                past: [],
                future: []
            }
        };

        let clipboard = null;
        let lastAction = null;
        let renderQueued = false;

        // Field index for O(1) lookup
        const fieldIndex = new Map();

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const controls = document.getElementById('controls');
        const pdfContainer = document.getElementById('pdfContainer');
        const status = document.getElementById('status');
        const addTextBtn = document.getElementById('addTextBtn');
        const addCheckboxBtn = document.getElementById('addCheckboxBtn');
        const addRadioBtn = document.getElementById('addRadioBtn');
        const addDropdownBtn = document.getElementById('addDropdownBtn');
        const clearFieldsBtn = document.getElementById('clearFieldsBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        // ==================== UTILITIES ====================

        function generateFieldId() {
            if (window.crypto && crypto.randomUUID) {
                return crypto.randomUUID();
            }
            return 'field-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        function findFieldById(fieldId) {
            return fieldIndex.get(fieldId);
        }

        function rebuildFieldIndex() {
            fieldIndex.clear();
            for (const page of state.pages) {
                for (const field of page.fields) {
                    fieldIndex.set(field.id, field);
                }
            }
        }

        function saveToHistory() {
            if (lastAction === 'select') return;

            const snapshot = {
                pages: JSON.parse(JSON.stringify(state.pages)),
                selectedFieldIds: [...state.selectedFieldIds]
            };

            state.history.past.push(snapshot);
            state.history.future = [];

            if (state.history.past.length > 50) {
                state.history.past.shift();
            }
        }

        function undo() {
            if (state.history.past.length === 0) return;

            const current = {
                pages: JSON.parse(JSON.stringify(state.pages)),
                selectedFieldIds: [...state.selectedFieldIds]
            };

            state.history.future.push(current);
            const previous = state.history.past.pop();

            state.pages = previous.pages;
            state.selectedFieldIds = previous.selectedFieldIds;
            rebuildFieldIndex();

            render();
            showStatus('Undo', false);
        }

        function redo() {
            if (state.history.future.length === 0) return;

            const current = {
                pages: JSON.parse(JSON.stringify(state.pages)),
                selectedFieldIds: [...state.selectedFieldIds]
            };

            state.history.past.push(current);
            const next = state.history.future.pop();

            state.pages = next.pages;
            state.selectedFieldIds = next.selectedFieldIds;
            rebuildFieldIndex();

            render();
            showStatus('Redo', false);
        }

        function render() {
            if (renderQueued) return;
            renderQueued = true;

            requestAnimationFrame(() => {
                if (state.pdf.doc) {
                    renderFieldOverlays();
                    updateAlignmentToolbar();
                }
                renderQueued = false;
            });
        }

        function showStatus(message, isError) {
            status.textContent = message;
            status.className = 'visible';
            if (isError) {
                status.setAttribute('aria-invalid', 'true');
            } else {
                status.removeAttribute('aria-invalid');
            }
        }

        // ==================== FILE UPLOAD ====================

        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            handleFiles(Array.from(e.dataTransfer.files));
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(Array.from(e.target.files));
        });

        async function handleFiles(files) {
            const pdfFiles = files.filter(f => f.type === 'application/pdf');

            if (pdfFiles.length === 0) {
                showStatus('Please select a PDF file', true);
                return;
            }

            if (pdfFiles.length > 1) {
                showStatus('Please select only one PDF file', true);
                return;
            }

            const file = pdfFiles[0];

            if (file.size > MAX_FILE_SIZE) {
                showStatus(`File too large: ${(file.size / (1024 * 1024)).toFixed(1)} MB. Maximum allowed: 50 MB`, true);
                return;
            }

            try {
                showStatus('Loading PDF...', false);
                const arrayBuffer = await file.arrayBuffer();

                // Follow PATTERNS.md PDF Byte Handling guidance
                // Create initial Uint8Array from the ArrayBuffer
                const initialView = new Uint8Array(arrayBuffer);

                // Create first copy for pdf.js using .set() method (CORRECT approach from PATTERNS.md)
                const pdfJsBytes = new Uint8Array(initialView.length);
                pdfJsBytes.set(initialView);

                // Create second independent copy for storage using .set() method
                const storedBytes = new Uint8Array(initialView.length);
                storedBytes.set(initialView);

                const pdfDoc = await pdfjsLib.getDocument(pdfJsBytes).promise;

                // Initialize state (store bytes copy for later download)
                state.pdf.doc = pdfDoc;
                state.pdf.fileName = file.name;
                state.pdf.bytes = storedBytes;  // Store completely independent copy
                state.pages = [];
                state.currentPage = 0;
                state.selectedFieldIds = [];
                state.history.past = [];
                state.history.future = [];

                // Create page entries
                for (let i = 1; i <= pdfDoc.numPages; i++) {
                    const page = await pdfDoc.getPage(i);
                    const viewport = page.getViewport({ scale: PDF_SCALE });
                    state.pages.push({
                        num: i,
                        width: viewport.width,
                        height: viewport.height,
                        scale: PDF_SCALE,
                        fields: []
                    });
                }

                rebuildFieldIndex();
                await renderPDFPages();

                uploadSection.style.display = 'none';
                controls.classList.add('visible');
                showStatus(`PDF loaded: ${pdfDoc.numPages} page(s)`, false);
            } catch (error) {
                showStatus(`Error loading PDF: ${error.message}`, true);
                state.pdf.doc = null;
            }
        }

        async function renderPDFPages() {
            pdfContainer.innerHTML = '';

            for (let i = 0; i < state.pages.length; i++) {
                const pageNum = i + 1;
                const pageDef = state.pages[i];
                const page = await state.pdf.doc.getPage(pageNum);

                const canvas = document.createElement('canvas');
                canvas.width = pageDef.width;
                canvas.height = pageDef.height;

                const context = canvas.getContext('2d');
                await page.render({
                    canvasContext: context,
                    viewport: page.getViewport({ scale: pageDef.scale })
                }).promise;

                const wrapper = document.createElement('div');
                wrapper.className = 'pdf-page-wrapper';
                wrapper.setAttribute('data-page', pageNum);
                wrapper.style.width = pageDef.width + 'px';
                wrapper.style.position = 'relative';

                canvas.className = 'pdf-page-canvas';
                canvas.setAttribute('data-page', pageNum);
                canvas.addEventListener('click', (e) => handleCanvasClick(e, pageNum));
                canvas.addEventListener('mousedown', (e) => handleCanvasMouseDown(e, pageNum));

                const fieldsContainer = document.createElement('div');
                fieldsContainer.style.position = 'absolute';
                fieldsContainer.style.top = '0';
                fieldsContainer.style.left = '0';
                fieldsContainer.style.width = '100%';
                fieldsContainer.style.height = '100%';
                fieldsContainer.className = 'fields-container';
                fieldsContainer.setAttribute('data-page', pageNum);

                wrapper.appendChild(canvas);
                wrapper.appendChild(fieldsContainer);
                pdfContainer.appendChild(wrapper);
            }

            renderFieldOverlays();
        }

        // ==================== FIELD CREATION & INTERACTION ====================

        function handleCanvasClick(e, pageNum) {
            // Only handle if not creating a field
            if (state.activeTool) return;

            lastAction = 'click';

            // If not shift+clicking, deselect all
            if (!e.shiftKey) {
                state.selectedFieldIds = [];
            }

            render();
        }

        function handleCanvasMouseDown(e, pageNum) {
            // Handle field creation
            if (state.activeTool) {
                handleFieldCreationStart(e, pageNum);
                return;
            }

            // Handle lasso selection
            if (!state.activeTool && e.button === 0) {
                handleLassoStart(e, pageNum);
            }
        }

        function handleFieldCreationStart(e, pageNum) {
            const canvas = e.target;
            const rect = canvas.parentElement.getBoundingClientRect();
            const startX = e.clientX - rect.left;
            const startY = e.clientY - rect.top;

            const fieldId = generateFieldId();
            const newField = {
                id: fieldId,
                type: state.activeTool,
                page: pageNum - 1,
                x: startX,
                y: startY,
                width: 0,
                height: 0,
                name: `${state.activeTool}_${Date.now()}`,
                value: state.activeTool === 'checkbox' ? false : '',
                defaultValue: '',
                placeholder: ''
            };

            // Handle special types
            if (state.activeTool === 'radio') {
                const groupName = prompt('Enter radio button group name:');
                if (!groupName) return;
                newField.name = groupName;
            } else if (state.activeTool === 'dropdown') {
                const optionsStr = prompt('Enter options (comma-separated):');
                if (!optionsStr) return;
                newField.options = optionsStr.split(',').map(o => o.trim());
                newField.value = newField.options[0] || '';
            }

            state.pages[pageNum - 1].fields.push(newField);
            fieldIndex.set(fieldId, newField);

            state.dragState = {
                type: 'drawing',
                fieldId,
                startX,
                startY,
                pageNum,
                canvas
            };

            document.addEventListener('mousemove', handleDrawingMove);
            document.addEventListener('mouseup', handleDrawingEnd);

            render();
        }

        function handleDrawingMove(e) {
            if (!state.dragState || state.dragState.type !== 'drawing') return;

            const canvas = state.dragState.canvas;
            const rect = canvas.parentElement.getBoundingClientRect();
            const currentX = e.clientX - rect.left;
            const currentY = e.clientY - rect.top;

            const field = findFieldById(state.dragState.fieldId);
            if (!field) return;

            field.x = Math.min(state.dragState.startX, currentX);
            field.y = Math.min(state.dragState.startY, currentY);
            field.width = Math.abs(currentX - state.dragState.startX);
            field.height = Math.abs(currentY - state.dragState.startY);

            field.width = Math.max(field.width, 20);
            field.height = Math.max(field.height, 20);

            render();
        }

        function handleDrawingEnd(e) {
            if (!state.dragState || state.dragState.type !== 'drawing') return;

            const field = findFieldById(state.dragState.fieldId);
            if (field && (field.width < 20 || field.height < 20)) {
                field.width = 100;
                field.height = 30;
            }

            saveToHistory();
            state.dragState = null;

            document.removeEventListener('mousemove', handleDrawingMove);
            document.removeEventListener('mouseup', handleDrawingEnd);

            render();
            showStatus(`${state.activeTool} field created`, false);
        }

        // ==================== LASSO SELECTION ====================

        function handleLassoStart(e, pageNum) {
            const canvas = e.target;
            const rect = canvas.parentElement.getBoundingClientRect();
            const startX = e.clientX - rect.left;
            const startY = e.clientY - rect.top;

            state.dragState = {
                type: 'lasso',
                startX,
                startY,
                currentX: startX,
                currentY: startY,
                pageNum,
                canvas
            };

            document.addEventListener('mousemove', handleLassoMove);
            document.addEventListener('mouseup', handleLassoEnd);
        }

        function handleLassoMove(e) {
            if (!state.dragState || state.dragState.type !== 'lasso') return;

            const canvas = state.dragState.canvas;
            const rect = canvas.parentElement.getBoundingClientRect();

            state.dragState.currentX = e.clientX - rect.left;
            state.dragState.currentY = e.clientY - rect.top;

            render();
        }

        function handleLassoEnd(e) {
            if (!state.dragState || state.dragState.type !== 'lasso') return;

            const lassoX1 = Math.min(state.dragState.startX, state.dragState.currentX);
            const lassoY1 = Math.min(state.dragState.startY, state.dragState.currentY);
            const lassoX2 = Math.max(state.dragState.startX, state.dragState.currentX);
            const lassoY2 = Math.max(state.dragState.startY, state.dragState.currentY);

            const page = state.pages[state.dragState.pageNum - 1];
            const intersectingIds = page.fields.filter(field => {
                return !(field.x + field.width < lassoX1 ||
                         field.x > lassoX2 ||
                         field.y + field.height < lassoY1 ||
                         field.y > lassoY2);
            }).map(f => f.id);

            if (e.shiftKey) {
                state.selectedFieldIds = [...new Set([...state.selectedFieldIds, ...intersectingIds])];
            } else {
                state.selectedFieldIds = intersectingIds;
            }

            state.dragState = null;

            document.removeEventListener('mousemove', handleLassoMove);
            document.removeEventListener('mouseup', handleLassoEnd);

            render();
            lastAction = 'select';
        }

        // ==================== FIELD RENDERING ====================

        function renderFieldOverlays() {
            const fieldsContainers = document.querySelectorAll('.fields-container');
            fieldsContainers.forEach(container => container.innerHTML = '');

            // Draw lasso if active
            if (state.dragState && state.dragState.type === 'lasso') {
                const wrapper = document.querySelector(`.pdf-page-wrapper[data-page="${state.dragState.pageNum}"]`);
                if (wrapper) {
                    const x = Math.min(state.dragState.startX, state.dragState.currentX);
                    const y = Math.min(state.dragState.startY, state.dragState.currentY);
                    const w = Math.abs(state.dragState.currentX - state.dragState.startX);
                    const h = Math.abs(state.dragState.currentY - state.dragState.startY);

                    const lasso = document.createElement('div');
                    lasso.className = 'lasso-rect';
                    lasso.style.left = x + 'px';
                    lasso.style.top = y + 'px';
                    lasso.style.width = w + 'px';
                    lasso.style.height = h + 'px';
                    wrapper.appendChild(lasso);
                }
            }

            // Draw fields
            for (const page of state.pages) {
                const container = document.querySelector(`.fields-container[data-page="${page.num}"]`);
                if (!container) continue;

                for (const field of page.fields) {
                    const wrapper = document.createElement('div');
                    wrapper.className = 'field-overlay';
                    if (field.type === 'text' || field.type === 'dropdown') {
                        wrapper.classList.add('resizable');
                    }
                    if (state.selectedFieldIds.includes(field.id)) {
                        wrapper.classList.add('selected');
                    }

                    wrapper.style.left = field.x + 'px';
                    wrapper.style.top = field.y + 'px';
                    wrapper.style.width = field.width + 'px';
                    wrapper.style.height = field.height + 'px';
                    wrapper.setAttribute('data-field-id', field.id);

                    // Create input
                    let input;
                    if (field.type === 'text') {
                        input = document.createElement('input');
                        input.type = 'text';
                        input.value = field.value || '';
                        input.addEventListener('change', (e) => {
                            field.value = e.target.value;
                        });
                    } else if (field.type === 'checkbox') {
                        input = document.createElement('input');
                        input.type = 'checkbox';
                        input.checked = field.value || false;
                        input.addEventListener('change', (e) => {
                            field.value = e.target.checked;
                        });
                    } else if (field.type === 'radio') {
                        input = document.createElement('input');
                        input.type = 'radio';
                        input.name = field.name;
                        input.value = 'on';
                        input.checked = field.value === 'on';
                        input.addEventListener('change', (e) => {
                            field.value = e.target.checked ? 'on' : 'off';
                        });
                    } else if (field.type === 'dropdown') {
                        input = document.createElement('select');
                        if (field.options) {
                            field.options.forEach(opt => {
                                const option = document.createElement('option');
                                option.value = opt;
                                option.textContent = opt;
                                input.appendChild(option);
                            });
                        }
                        input.value = field.value || '';
                        input.addEventListener('change', (e) => {
                            field.value = e.target.value;
                        });
                    }

                    if (input) wrapper.appendChild(input);

                    // Add delete button
                    const deleteBtn = document.createElement('button');
                    deleteBtn.className = 'field-delete-btn';
                    deleteBtn.textContent = '√ó';
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteField(field.id);
                    });
                    wrapper.appendChild(deleteBtn);

                    // Handle selection
                    wrapper.addEventListener('click', (e) => {
                        if (e.target === input) return;
                        e.stopPropagation();
                        lastAction = 'select';

                        if (e.shiftKey) {
                            const idx = state.selectedFieldIds.indexOf(field.id);
                            if (idx >= 0) {
                                state.selectedFieldIds.splice(idx, 1);
                            } else {
                                state.selectedFieldIds.push(field.id);
                            }
                        } else {
                            state.selectedFieldIds = [field.id];
                        }

                        render();
                    });

                    // Handle dragging
                    makeDraggable(wrapper, field, page.num);

                    // Handle resizing
                    if (field.type === 'text' || field.type === 'dropdown') {
                        makeResizable(wrapper, field);
                    }

                    container.appendChild(wrapper);
                }
            }
        }

        // ==================== DRAG AND RESIZE ====================

        function makeDraggable(element, field, pageNum) {
            let offsetX = 0;
            let offsetY = 0;
            let isMouseDown = false;

            element.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('field-delete-btn')) return;
                if (e.target !== element && element.contains(e.target)) {
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        return;
                    }
                }

                isMouseDown = true;
                const rect = element.getBoundingClientRect();
                const parentRect = element.parentElement.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;

                element.style.zIndex = 1000;

                const handleMouseMove = (moveEvent) => {
                    if (!isMouseDown) return;

                    let x = moveEvent.clientX - parentRect.left - offsetX;
                    let y = moveEvent.clientY - parentRect.top - offsetY;

                    // Apply snap-to-grid
                    const gridSnapped = applySnapToGrid(x, y);
                    x = gridSnapped.x;
                    y = gridSnapped.y;

                    // Apply snap-to-fields
                    const fieldSnap = findSnapTargets(field, x, y);
                    x = fieldSnap.x;
                    y = fieldSnap.y;

                    // Render snap guides
                    if (fieldSnap.snapLines.length > 0) {
                        renderSnapGuides(fieldSnap.snapLines, pageNum);
                    }

                    // Constrain to bounds
                    x = Math.max(0, Math.min(x, parentRect.width - element.offsetWidth));
                    y = Math.max(0, Math.min(y, parentRect.height - element.offsetHeight));

                    element.style.left = x + 'px';
                    element.style.top = y + 'px';

                    field.x = x;
                    field.y = y;
                };

                const handleMouseUp = () => {
                    isMouseDown = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    element.style.zIndex = 'auto';

                    // Remove snap guides
                    const wrapper = document.querySelector(`.pdf-page-wrapper[data-page="${pageNum}"]`);
                    if (wrapper) {
                        wrapper.querySelectorAll('.snap-guide').forEach(g => g.remove());
                    }

                    saveToHistory();
                    render();
                };

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });
        }

        function makeResizable(element, field) {
            let isResizing = false;

            element.addEventListener('mousedown', (e) => {
                const rect = element.getBoundingClientRect();
                const isHandle = (e.clientX >= rect.right - 12 && e.clientX <= rect.right + 6 &&
                                  e.clientY >= rect.bottom - 12 && e.clientY <= rect.bottom + 6);

                if (!isHandle) return;

                isResizing = true;
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = element.offsetWidth;
                const startHeight = element.offsetHeight;

                const handleMouseMove = (moveEvent) => {
                    if (!isResizing) return;

                    const newWidth = Math.max(40, startWidth + (moveEvent.clientX - startX));
                    const newHeight = Math.max(20, startHeight + (moveEvent.clientY - startY));

                    element.style.width = newWidth + 'px';
                    element.style.height = newHeight + 'px';

                    field.width = newWidth;
                    field.height = newHeight;
                };

                const handleMouseUp = () => {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    saveToHistory();
                    render();
                };

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                e.preventDefault();
            });
        }

        // ==================== FIELD OPERATIONS ====================

        function deleteField(fieldId) {
            for (const page of state.pages) {
                page.fields = page.fields.filter(f => f.id !== fieldId);
            }
            fieldIndex.delete(fieldId);
            const idx = state.selectedFieldIds.indexOf(fieldId);
            if (idx >= 0) state.selectedFieldIds.splice(idx, 1);
            saveToHistory();
            render();
            showStatus('Field deleted', false);
        }

        function copySelectedFields() {
            if (state.selectedFieldIds.length === 0) {
                showStatus('No fields selected', true);
                return;
            }
            clipboard = state.selectedFieldIds.map(id => {
                const field = findFieldById(id);
                return JSON.parse(JSON.stringify(field));
            });
            showStatus(`Copied ${clipboard.length} field(s)`, false);
        }

        function pasteFields() {
            if (!clipboard || clipboard.length === 0) {
                showStatus('Nothing to paste', true);
                return;
            }

            saveToHistory();

            const newFieldIds = [];
            const offsetX = 10;
            const offsetY = 10;

            for (const sourceField of clipboard) {
                const newField = {
                    ...JSON.parse(JSON.stringify(sourceField)),
                    id: generateFieldId(),
                    x: sourceField.x + offsetX,
                    y: sourceField.y + offsetY,
                    name: `${sourceField.name}_copy`
                };

                state.pages[state.currentPage].fields.push(newField);
                fieldIndex.set(newField.id, newField);
                newFieldIds.push(newField.id);
            }

            state.selectedFieldIds = newFieldIds;
            render();
            showStatus(`Pasted ${clipboard.length} field(s)`, false);
        }

        // ==================== SMART ALIGNMENT ====================

        function applySnapToGrid(x, y) {
            if (!state.settings.snapToGrid) return { x, y };
            const gridSize = state.settings.gridSize;
            return {
                x: Math.round(x / gridSize) * gridSize,
                y: Math.round(y / gridSize) * gridSize
            };
        }

        function findSnapTargets(field, currentX, currentY) {
            if (!state.settings.snapToFields) return { x: currentX, y: currentY, snapLines: [] };

            const page = state.pages[field.page];
            if (!page) return { x: currentX, y: currentY, snapLines: [] };

            const threshold = state.settings.snapThreshold;
            const snapLines = [];
            let snappedX = currentX;
            let snappedY = currentY;

            // Check against all other fields on same page
            for (const otherField of page.fields) {
                if (otherField.id === field.id || state.selectedFieldIds.includes(otherField.id)) {
                    continue;
                }

                // Left edge
                if (Math.abs(currentX - otherField.x) < threshold) {
                    snappedX = otherField.x;
                    snapLines.push({ type: 'vertical', x: otherField.x, color: '#ff0066' });
                }

                // Right edge
                const currentRight = currentX + field.width;
                const otherRight = otherField.x + otherField.width;
                if (Math.abs(currentRight - otherRight) < threshold) {
                    snappedX = otherRight - field.width;
                    snapLines.push({ type: 'vertical', x: otherRight, color: '#ff0066' });
                }

                // Top edge
                if (Math.abs(currentY - otherField.y) < threshold) {
                    snappedY = otherField.y;
                    snapLines.push({ type: 'horizontal', y: otherField.y, color: '#ff0066' });
                }

                // Bottom edge
                const currentBottom = currentY + field.height;
                const otherBottom = otherField.y + otherField.height;
                if (Math.abs(currentBottom - otherBottom) < threshold) {
                    snappedY = otherBottom - field.height;
                    snapLines.push({ type: 'horizontal', y: otherBottom, color: '#ff0066' });
                }

                // Center horizontal
                const currentCenterX = currentX + field.width / 2;
                const otherCenterX = otherField.x + otherField.width / 2;
                if (Math.abs(currentCenterX - otherCenterX) < threshold) {
                    snappedX = otherCenterX - field.width / 2;
                    snapLines.push({ type: 'vertical', x: otherCenterX, color: '#ff3366' });
                }

                // Center vertical
                const currentCenterY = currentY + field.height / 2;
                const otherCenterY = otherField.y + otherField.height / 2;
                if (Math.abs(currentCenterY - otherCenterY) < threshold) {
                    snappedY = otherCenterY - field.height / 2;
                    snapLines.push({ type: 'horizontal', y: otherCenterY, color: '#ff3366' });
                }
            }

            return { x: snappedX, y: snappedY, snapLines };
        }

        function renderSnapGuides(snapLines, pageNum) {
            const wrapper = document.querySelector(`.pdf-page-wrapper[data-page="${pageNum}"]`);
            if (!wrapper) return;

            wrapper.querySelectorAll('.snap-guide').forEach(g => g.remove());

            for (const line of snapLines) {
                const guide = document.createElement('div');
                guide.className = 'snap-guide';
                guide.style.backgroundColor = line.color;

                if (line.type === 'vertical') {
                    guide.style.left = line.x + 'px';
                    guide.style.top = '0';
                    guide.style.width = '1px';
                    guide.style.height = '100%';
                } else {
                    guide.style.top = line.y + 'px';
                    guide.style.left = '0';
                    guide.style.height = '1px';
                    guide.style.width = '100%';
                }

                wrapper.appendChild(guide);
            }
        }

        // Alignment functions
        function alignLeft() {
            if (state.selectedFieldIds.length < 2) {
                showStatus('Select 2+ fields to align', true);
                return;
            }

            saveToHistory();

            const fields = state.selectedFieldIds.map(findFieldById).filter(f => f);
            if (fields.length === 0) return;

            const minX = Math.min(...fields.map(f => f.x));

            fields.forEach(field => {
                field.x = minX;
            });

            render();
            showStatus(`Aligned ${fields.length} fields to left`, false);
        }

        function alignRight() {
            if (state.selectedFieldIds.length < 2) {
                showStatus('Select 2+ fields to align', true);
                return;
            }

            saveToHistory();

            const fields = state.selectedFieldIds.map(findFieldById).filter(f => f);
            if (fields.length === 0) return;

            const maxRight = Math.max(...fields.map(f => f.x + f.width));

            fields.forEach(field => {
                field.x = maxRight - field.width;
            });

            render();
            showStatus(`Aligned ${fields.length} fields to right`, false);
        }

        function alignTop() {
            if (state.selectedFieldIds.length < 2) {
                showStatus('Select 2+ fields to align', true);
                return;
            }

            saveToHistory();

            const fields = state.selectedFieldIds.map(findFieldById).filter(f => f);
            if (fields.length === 0) return;

            const minY = Math.min(...fields.map(f => f.y));

            fields.forEach(field => {
                field.y = minY;
            });

            render();
            showStatus(`Aligned ${fields.length} fields to top`, false);
        }

        function alignBottom() {
            if (state.selectedFieldIds.length < 2) {
                showStatus('Select 2+ fields to align', true);
                return;
            }

            saveToHistory();

            const fields = state.selectedFieldIds.map(findFieldById).filter(f => f);
            if (fields.length === 0) return;

            const maxBottom = Math.max(...fields.map(f => f.y + f.height));

            fields.forEach(field => {
                field.y = maxBottom - field.height;
            });

            render();
            showStatus(`Aligned ${fields.length} fields to bottom`, false);
        }

        function distributeHorizontally() {
            if (state.selectedFieldIds.length < 3) {
                showStatus('Select 3+ fields to distribute', true);
                return;
            }

            saveToHistory();

            const fields = state.selectedFieldIds.map(findFieldById).filter(f => f);
            if (fields.length < 3) return;

            fields.sort((a, b) => a.x - b.x);

            const first = fields[0];
            const last = fields[fields.length - 1];
            const totalSpan = (last.x + last.width) - first.x;
            const totalFieldWidth = fields.reduce((sum, f) => sum + f.width, 0);
            const spacing = (totalSpan - totalFieldWidth) / (fields.length - 1);

            let currentX = first.x + first.width + spacing;
            for (let i = 1; i < fields.length - 1; i++) {
                fields[i].x = currentX;
                currentX += fields[i].width + spacing;
            }

            render();
            showStatus(`Distributed ${fields.length} fields horizontally`, false);
        }

        function distributeVertically() {
            if (state.selectedFieldIds.length < 3) {
                showStatus('Select 3+ fields to distribute', true);
                return;
            }

            saveToHistory();

            const fields = state.selectedFieldIds.map(findFieldById).filter(f => f);
            if (fields.length < 3) return;

            fields.sort((a, b) => a.y - b.y);

            const first = fields[0];
            const last = fields[fields.length - 1];
            const totalSpan = (last.y + last.height) - first.y;
            const totalFieldHeight = fields.reduce((sum, f) => sum + f.height, 0);
            const spacing = (totalSpan - totalFieldHeight) / (fields.length - 1);

            let currentY = first.y + first.height + spacing;
            for (let i = 1; i < fields.length - 1; i++) {
                fields[i].y = currentY;
                currentY += fields[i].height + spacing;
            }

            render();
            showStatus(`Distributed ${fields.length} fields vertically`, false);
        }

        function updateAlignmentToolbar() {
            const alignmentTools = document.getElementById('alignmentTools');
            if (state.selectedFieldIds.length >= 2) {
                alignmentTools.style.display = 'flex';
            } else {
                alignmentTools.style.display = 'none';
            }
        }

        // ==================== BUTTON HANDLERS ====================

        [addTextBtn, addCheckboxBtn, addRadioBtn, addDropdownBtn].forEach(btn => {
            btn.addEventListener('click', () => {
                [addTextBtn, addCheckboxBtn, addRadioBtn, addDropdownBtn].forEach(b => b.classList.remove('active'));

                if (state.activeTool === btn.dataset.type) {
                    state.activeTool = null;
                    btn.classList.remove('active');
                    showStatus('Field placement cancelled', false);
                } else {
                    state.activeTool = btn.dataset.type;
                    btn.classList.add('active');
                    showStatus(`Click and drag on PDF to create a ${state.activeTool} field`, false);
                }
            });
        });

        // Alignment button handlers
        document.getElementById('alignLeftBtn').addEventListener('click', alignLeft);
        document.getElementById('alignRightBtn').addEventListener('click', alignRight);
        document.getElementById('alignTopBtn').addEventListener('click', alignTop);
        document.getElementById('alignBottomBtn').addEventListener('click', alignBottom);
        document.getElementById('distributeHBtn').addEventListener('click', distributeHorizontally);
        document.getElementById('distributeVBtn').addEventListener('click', distributeVertically);

        clearFieldsBtn.addEventListener('click', () => {
            if (state.pages.every(p => p.fields.length === 0)) {
                showStatus('No fields to clear', true);
                return;
            }

            if (confirm('Are you sure you want to delete all fields? This cannot be undone.')) {
                saveToHistory();
                for (const page of state.pages) {
                    page.fields = [];
                }
                fieldIndex.clear();
                state.selectedFieldIds = [];
                render();
                showStatus('All fields cleared', false);
            }
        });

        downloadBtn.addEventListener('click', downloadFilledPDF);

        // ==================== KEYBOARD SHORTCUTS ====================

        document.addEventListener('keydown', (e) => {
            // Check if user is typing in a text input/textarea
            const isTypingInInput = (e.target.tagName === 'INPUT' && e.target.type === 'text') ||
                                    e.target.tagName === 'TEXTAREA' ||
                                    (e.target.tagName === 'SELECT');

            // Check if we're in the PDF editor context (keyboard shortcuts should only work when focused in editor)
            const isInPDFEditor = isTypingInInput || pdfContainer.contains(e.target);

            const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
            const cmdKey = isMac ? e.metaKey : e.ctrlKey;

            // Undo: Cmd/Ctrl+Z (only works in editor, not in text inputs)
            if (cmdKey && e.key === 'z' && !e.shiftKey && !isTypingInInput && state.pdf.doc) {
                e.preventDefault();
                undo();
            }

            // Redo: Cmd/Ctrl+Shift+Z (only works in editor, not in text inputs)
            if (cmdKey && e.key === 'z' && e.shiftKey && !isTypingInInput && state.pdf.doc) {
                e.preventDefault();
                redo();
            }

            // Copy: Cmd/Ctrl+C (only for field selection, not in text inputs, and only in PDF editor)
            if (cmdKey && e.key === 'c' && !isTypingInInput && state.pdf.doc && isInPDFEditor) {
                e.preventDefault();
                copySelectedFields();
            }

            // Paste: Cmd/Ctrl+V (only for field pasting, not in text inputs, and only in PDF editor)
            if (cmdKey && e.key === 'v' && !isTypingInInput && state.pdf.doc && isInPDFEditor) {
                e.preventDefault();
                pasteFields();
            }

            // Delete: Backspace or Delete (only for field deletion, not in text inputs, and only in PDF editor)
            if ((e.key === 'Delete' || e.key === 'Backspace') && !isTypingInInput && state.pdf.doc && isInPDFEditor) {
                e.preventDefault();
                if (state.selectedFieldIds.length > 0) {
                    const ids = [...state.selectedFieldIds];
                    saveToHistory();
                    ids.forEach(id => deleteField(id));
                }
            }

            // Deselect: Escape (always works unless in text input)
            if (e.key === 'Escape' && !isTypingInInput) {
                state.selectedFieldIds = [];
                state.activeTool = null;
                [addTextBtn, addCheckboxBtn, addRadioBtn, addDropdownBtn].forEach(b => b.classList.remove('active'));
                render();
            }
        });

        document.addEventListener('click', (e) => {
            if (!e.target.closest('.toolbar') && !e.target.closest('.pdf-page-wrapper')) {
                state.selectedFieldIds = [];
                render();
            }
        });

        // ==================== PDF EXPORT ====================

        async function downloadFilledPDF() {
            if (!state.pdf.bytes || !state.pdf.doc) {
                showStatus('No PDF loaded', true);
                return;
            }

            try {
                showStatus('Preparing PDF for download...', false);
                downloadBtn.disabled = true;

                // Follow PATTERNS.md PDF Byte Handling guidance
                // Create a fresh independent copy using .set() method (CORRECT approach)
                let pdfBytes;
                if (state.pdf.bytes instanceof Uint8Array) {
                    // Create empty Uint8Array and copy data into it using .set()
                    // This prevents detached ArrayBuffer issues when PDFLib processes the bytes
                    pdfBytes = new Uint8Array(state.pdf.bytes.length);
                    pdfBytes.set(state.pdf.bytes);
                } else {
                    // Fallback for raw ArrayBuffer
                    pdfBytes = new Uint8Array(state.pdf.bytes);
                }

                const pdfData = await PDFLib.PDFDocument.load(pdfBytes);
                const pages = pdfData.getPages();

                for (const page of state.pages) {
                    if (page.num - 1 >= pages.length) continue;

                    const pdfPage = pages[page.num - 1];
                    const pageHeight = pdfPage.getHeight();

                    for (const field of page.fields) {
                        const pdfX = field.x / page.scale;
                        const pdfY = pageHeight - (field.y / page.scale) - (field.height / page.scale);
                        const pdfHeight = field.height / page.scale;
                        const fontSize = Math.max(8, Math.min(pdfHeight * 0.7, 14));

                        if (field.type === 'text') {
                            pdfPage.drawText(field.value || '', {
                                x: pdfX,
                                y: pdfY,
                                size: fontSize,
                                color: PDFLib.rgb(0, 0, 0)
                            });
                        } else if (field.type === 'checkbox') {
                            if (field.value) {
                                pdfPage.drawText('‚úì', {
                                    x: pdfX + 2,
                                    y: pdfY,
                                    size: fontSize,
                                    color: PDFLib.rgb(0, 0, 0)
                                });
                            }
                        } else if (field.type === 'radio') {
                            if (field.value === 'on') {
                                const pdfWidth = field.width / page.scale;
                                pdfPage.drawCircle({
                                    x: pdfX + pdfWidth / 2,
                                    y: pdfY + pdfHeight / 2,
                                    size: pdfHeight / 3,
                                    color: PDFLib.rgb(0, 0, 0),
                                    borderColor: PDFLib.rgb(0, 0, 0),
                                    borderWidth: 0
                                });
                            }
                        } else if (field.type === 'dropdown') {
                            pdfPage.drawText(field.value || '', {
                                x: pdfX,
                                y: pdfY,
                                size: fontSize,
                                color: PDFLib.rgb(0, 0, 0)
                            });
                        }
                    }
                }

                const outputBytes = await pdfData.save();
                const blob = new Blob([outputBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'filled-form.pdf';
                a.click();
                URL.revokeObjectURL(url);

                showStatus('PDF downloaded successfully', false);
                downloadBtn.disabled = false;
            } catch (error) {
                console.error('PDF download error:', error);
                showStatus(`Error downloading PDF: ${error.message}`, true);
                downloadBtn.disabled = false;
            }
        }
    </script>
</body>
</html>
