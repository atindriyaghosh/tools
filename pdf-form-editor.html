<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF Form Editor</title>
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <link rel="stylesheet" href="common-styles.css">
    <style>
        .upload-area {
            border: 2px dashed var(--pico-muted-border-color);
            border-radius: var(--pico-border-radius);
            padding: 2rem 1.25rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
        }

        .upload-area:hover {
            border-color: #6b8dd6;
            background: rgba(107, 141, 214, 0.05);
        }

        .upload-area.drag-over {
            border-color: #6b8dd6;
            background: rgba(107, 141, 214, 0.1);
        }

        input[type="file"] {
            display: none;
        }

        #controls {
            display: none;
        }

        #controls.visible {
            display: block;
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .toolbar button {
            flex: 0 1 auto;
        }

        .toolbar button.active {
            background-color: #4a6fa5;
            border-color: #4a6fa5;
        }

        .pdf-container {
            background: #f5f5f5;
            padding: 1rem;
            border-radius: var(--pico-border-radius);
            max-height: 70vh;
            overflow-y: auto;
            position: relative;
        }

        .pdf-page-wrapper {
            position: relative;
            margin-bottom: 1rem;
            background: white;
            display: inline-block;
            width: 100%;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .pdf-page-canvas {
            display: block;
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
        }

        .fields-container {
            pointer-events: none;
        }

        .field-overlay {
            position: absolute;
            border: 2px solid #6b8dd6;
            background: rgba(107, 141, 214, 0.05);
            box-sizing: border-box;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: move;
            transition: border-color 0.2s;
            pointer-events: auto;
        }

        .field-overlay:hover {
            border-color: #4a6fa5;
            background: rgba(107, 141, 214, 0.1);
        }

        .field-overlay.selected {
            border-color: #4a6fa5;
            background: rgba(107, 141, 214, 0.15);
        }

        .field-overlay input,
        .field-overlay select {
            width: 100%;
            height: 100%;
            border: none;
            background: none;
            padding: 0.2rem;
            font-size: 0.9rem;
            box-sizing: border-box;
        }

        .field-overlay input:focus,
        .field-overlay select:focus {
            outline: none;
        }

        .field-delete-btn {
            position: absolute;
            top: -12px;
            right: -12px;
            width: 24px;
            height: 24px;
            padding: 0;
            background: #dc3545;
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 0.75rem;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .field-overlay.selected .field-delete-btn {
            display: flex;
        }

        .field-overlay.resizable::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: #6b8dd6;
            bottom: -6px;
            right: -6px;
            cursor: se-resize;
            display: none;
        }

        .field-overlay.resizable.selected::after {
            display: block;
        }

        .instructions {
            background: rgba(107, 141, 214, 0.05);
            border-left: 4px solid #6b8dd6;
            padding: 1rem;
            margin-bottom: 1rem;
            border-radius: 0.25rem;
        }

        .instructions h3 {
            margin-top: 0;
            margin-bottom: 0.5rem;
        }

        .instructions ol {
            margin: 0;
            padding-left: 1.5rem;
        }

        .instructions li {
            margin-bottom: 0.25rem;
        }

        #status {
            display: none;
            margin-top: 1rem;
            padding: 1rem;
            border-radius: var(--pico-border-radius);
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }

        #status[aria-invalid="true"] {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        #status.visible {
            display: block;
        }

        .field-type-group {
            margin-bottom: 1rem;
        }

        .field-type-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: bold;
        }

        .field-type-group input {
            width: 100%;
        }
    </style>
</head>
<body>
    <main class="container">
        <p style="margin-bottom: 1rem;"><a href="index.html" class="back-link">‚Üê Back to Tools</a></p>
        <hgroup>
            <h1>PDF Form Editor</h1>
            <p>Make static PDF forms editable by adding fillable fields</p>
        </hgroup>

        <article id="uploadSection">
            <div class="upload-area" id="uploadArea">
                <p>üìÑ Drop PDF here or click to upload</p>
                <p style="margin: 0; color: #999; font-size: 0.9rem;">Maximum file size: 50 MB</p>
                <input type="file" id="fileInput" accept=".pdf">
            </div>
        </article>

        <article id="controls">
            <div class="instructions">
                <h3>How to use:</h3>
                <ol>
                    <li><strong>Optional:</strong> Click "Auto-Detect Boxes" to automatically detect form fields</li>
                    <li>Or manually click a field type button and click on the PDF to place fields</li>
                    <li>Drag to reposition, drag corner to resize (text fields)</li>
                    <li>Click the field to select and delete with the X button</li>
                    <li>Fill in your values</li>
                    <li>Download when done</li>
                </ol>
            </div>

            <div class="toolbar">
                <button id="addTextBtn" data-type="text">+ Text Field</button>
                <button id="addCheckboxBtn" data-type="checkbox">+ Checkbox</button>
                <button id="addRadioBtn" data-type="radio">+ Radio Button</button>
                <button id="addDropdownBtn" data-type="dropdown">+ Dropdown</button>
                <button id="detectBoxesBtn" style="background-color: #6c757d; border-color: #6c757d;">üîç Auto-Detect Boxes</button>
                <button id="clearFieldsBtn" style="background-color: #dc3545; border-color: #dc3545;">Clear All Fields</button>
                <button id="downloadBtn" style="background-color: #28a745; border-color: #28a745;">Download PDF</button>
            </div>

            <div id="status"></div>

            <div class="pdf-container" id="pdfContainer"></div>
        </article>

        <p style="margin-top:1rem"><a href="index.html" class="back-link">‚Üê Back to Tools</a></p>
    </main>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
    <script async id="opencvScript" src="https://cdn.jsdelivr.net/npm/opencv.js@1.2.1/opencv.js"></script>
    <script>
        // Setup PDF.js worker
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';

        // State
        let pdfDoc = null;
        let originalPdfBytes = null;
        let fields = [];
        let activeTool = null;
        let isPlacingField = false;
        let currentPageNum = 0;
        const MAX_FILE_SIZE = 50 * 1024 * 1024; // 50 MB
        const PDF_SCALE = 1.5; // Scale factor for rendering PDFs
        const pageScales = {}; // Store scale factors for each page

        // Detection configuration
        const DETECTION_CONFIG = {
            MIN_BOX_SIZE: 3,            // Minimum box dimension in pixels (at 1.5x scale)
            MAX_BOX_SIZE: 200,          // Maximum box dimension for character boxes
            MIN_ASPECT_RATIO: 0.2,      // Prevent very elongated rectangles
            MAX_ASPECT_RATIO: 5.0,
            CANNY_LOW: 20,              // Edge detection threshold - balanced
            CANNY_HIGH: 80,             // Upper threshold for edge detection
            GAUSSIAN_KERNEL: 3,         // Blur kernel size (smaller = less blur)
            MIN_SOLIDITY: 0.25,         // Minimum solidity (hollow boxes ~30-50%)
            MAX_SOLIDITY: 0.65          // Maximum solidity (exclude filled text ~70%+)
        };
        let isDetecting = false; // Track detection state
        let opencvReady = false; // Track if OpenCV is loaded

        // DOM elements
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');
        const uploadSection = document.getElementById('uploadSection');
        const controls = document.getElementById('controls');
        const pdfContainer = document.getElementById('pdfContainer');
        const status = document.getElementById('status');
        const addTextBtn = document.getElementById('addTextBtn');
        const addCheckboxBtn = document.getElementById('addCheckboxBtn');
        const addRadioBtn = document.getElementById('addRadioBtn');
        const addDropdownBtn = document.getElementById('addDropdownBtn');
        const detectBoxesBtn = document.getElementById('detectBoxesBtn');
        const clearFieldsBtn = document.getElementById('clearFieldsBtn');
        const downloadBtn = document.getElementById('downloadBtn');

        // File upload handlers
        uploadArea.addEventListener('click', () => fileInput.click());

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('drag-over');
        });

        uploadArea.addEventListener('dragleave', () => {
            uploadArea.classList.remove('drag-over');
        });

        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('drag-over');
            handleFiles(Array.from(e.dataTransfer.files));
        });

        fileInput.addEventListener('change', (e) => {
            handleFiles(Array.from(e.target.files));
        });

        async function handleFiles(files) {
            const pdfFiles = files.filter(f => f.type === 'application/pdf');

            if (pdfFiles.length === 0) {
                showStatus('Please select a PDF file', true);
                return;
            }

            if (pdfFiles.length > 1) {
                showStatus('Please select only one PDF file', true);
                return;
            }

            const file = pdfFiles[0];

            if (file.size > MAX_FILE_SIZE) {
                showStatus(`File too large: ${(file.size / (1024 * 1024)).toFixed(1)} MB. Maximum allowed: 50 MB`, true);
                return;
            }

            try {
                showStatus('Loading PDF...', false);
                const arrayBuffer = await file.arrayBuffer();
                originalPdfBytes = new Uint8Array(arrayBuffer);
                pdfDoc = await pdfjsLib.getDocument(originalPdfBytes).promise;

                fields = [];
                await renderPDFPages();

                uploadSection.style.display = 'none';
                controls.classList.add('visible');
                showStatus(`PDF loaded: ${pdfDoc.numPages} page(s)`, false);
            } catch (error) {
                showStatus(`Error loading PDF: ${error.message}`, true);
                pdfDoc = null;
            }
        }

        async function renderPDFPages() {
            pdfContainer.innerHTML = '';
            const numPages = pdfDoc.numPages;

            for (let pageNum = 1; pageNum <= numPages; pageNum++) {
                const page = await pdfDoc.getPage(pageNum);
                const viewport = page.getViewport({ scale: PDF_SCALE });
                pageScales[pageNum - 1] = PDF_SCALE;

                const canvas = document.createElement('canvas');
                canvas.width = viewport.width;
                canvas.height = viewport.height;

                const context = canvas.getContext('2d');
                await page.render({
                    canvasContext: context,
                    viewport: viewport
                }).promise;

                const wrapper = document.createElement('div');
                wrapper.className = 'pdf-page-wrapper';
                wrapper.setAttribute('data-page', pageNum);
                wrapper.style.width = (viewport.width) + 'px';

                canvas.className = 'pdf-page-canvas';
                canvas.setAttribute('data-page', pageNum);
                canvas.addEventListener('click', (e) => handleCanvasClick(e, pageNum));

                const fieldsContainer = document.createElement('div');
                fieldsContainer.style.position = 'absolute';
                fieldsContainer.style.top = '0';
                fieldsContainer.style.left = '0';
                fieldsContainer.style.width = '100%';
                fieldsContainer.style.height = '100%';
                fieldsContainer.className = 'fields-container';
                fieldsContainer.setAttribute('data-page', pageNum);

                wrapper.appendChild(canvas);
                wrapper.appendChild(fieldsContainer);
                pdfContainer.appendChild(wrapper);
            }

            renderFieldOverlays();
        }

        function handleCanvasClick(e, pageNum) {
            if (!activeTool) {
                return;
            }

            const canvas = e.target;
            const rect = canvas.getBoundingClientRect();
            const containerRect = canvas.parentElement.getBoundingClientRect();

            const x = e.clientX - containerRect.left;
            const y = e.clientY - containerRect.top;

            if (x < 0 || y < 0 || x > canvas.offsetWidth || y > canvas.offsetHeight) {
                return;
            }

            let fieldData = {
                id: generateFieldId(),
                type: activeTool,
                page: pageNum - 1,
                x: Math.round(x),
                y: Math.round(y),
                width: 100,
                height: 30,
                value: ''
            };

            if (activeTool === 'radio') {
                const groupName = prompt('Enter radio button group name:');
                if (!groupName) return;
                fieldData.name = groupName;
                fieldData.value = 'off';
            } else if (activeTool === 'dropdown') {
                const optionsStr = prompt('Enter options (comma-separated):');
                if (!optionsStr) return;
                fieldData.options = optionsStr.split(',').map(o => o.trim());
                fieldData.value = fieldData.options[0] || '';
            } else if (activeTool === 'checkbox') {
                fieldData.value = false;
            }

            fields.push(fieldData);
            renderFieldOverlays();
            showStatus(`${activeTool.charAt(0).toUpperCase() + activeTool.slice(1)} field added`, false);
        }

        function renderFieldOverlays() {
            const fieldsContainers = document.querySelectorAll('.fields-container');
            fieldsContainers.forEach(container => container.innerHTML = '');

            fields.forEach(field => {
                const pageNum = field.page + 1;
                const container = document.querySelector(`.fields-container[data-page="${pageNum}"]`);
                if (!container) return;

                const wrapper = document.createElement('div');
                wrapper.className = 'field-overlay';
                if (field.type === 'text' || field.type === 'dropdown') {
                    wrapper.classList.add('resizable');
                }
                wrapper.style.left = field.x + 'px';
                wrapper.style.top = field.y + 'px';
                wrapper.style.width = field.width + 'px';
                wrapper.style.height = field.height + 'px';
                wrapper.setAttribute('data-field-id', field.id);

                let input;

                if (field.type === 'text') {
                    input = document.createElement('input');
                    input.type = 'text';
                    input.value = field.value;
                    if (field.maxLength) {
                        input.maxLength = field.maxLength;
                    }
                    input.addEventListener('change', (e) => {
                        const idx = fields.findIndex(f => f.id === field.id);
                        if (idx >= 0) fields[idx].value = e.target.value;
                    });
                    input.addEventListener('input', (e) => {
                        const idx = fields.findIndex(f => f.id === field.id);
                        if (idx >= 0) fields[idx].value = e.target.value;
                    });
                } else if (field.type === 'checkbox') {
                    input = document.createElement('input');
                    input.type = 'checkbox';
                    input.checked = field.value;
                    input.addEventListener('change', (e) => {
                        const idx = fields.findIndex(f => f.id === field.id);
                        if (idx >= 0) fields[idx].value = e.target.checked;
                    });
                } else if (field.type === 'radio') {
                    input = document.createElement('input');
                    input.type = 'radio';
                    input.name = field.name;
                    input.value = 'on';
                    input.checked = field.value === 'on';
                    input.addEventListener('change', (e) => {
                        const idx = fields.findIndex(f => f.id === field.id);
                        if (idx >= 0) fields[idx].value = e.target.checked ? 'on' : 'off';
                    });
                } else if (field.type === 'dropdown') {
                    input = document.createElement('select');
                    field.options.forEach(option => {
                        const opt = document.createElement('option');
                        opt.value = option;
                        opt.textContent = option;
                        input.appendChild(opt);
                    });
                    input.value = field.value;
                    input.addEventListener('change', (e) => {
                        const idx = fields.findIndex(f => f.id === field.id);
                        if (idx >= 0) fields[idx].value = e.target.value;
                    });
                }

                wrapper.appendChild(input);

                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'field-delete-btn';
                deleteBtn.textContent = '√ó';
                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteField(field.id);
                });
                wrapper.appendChild(deleteBtn);

                wrapper.addEventListener('click', (e) => {
                    if (e.target === input) return;
                    e.stopPropagation();
                    document.querySelectorAll('.field-overlay.selected').forEach(el => {
                        el.classList.remove('selected');
                    });
                    wrapper.classList.add('selected');
                });

                makeDraggable(wrapper, field);
                if (field.type === 'text' || field.type === 'dropdown') {
                    makeResizable(wrapper, field);
                }

                container.appendChild(wrapper);
            });
        }

        function makeDraggable(element, field) {
            let offsetX = 0;
            let offsetY = 0;
            let isMouseDown = false;

            element.addEventListener('mousedown', (e) => {
                if (e.target.classList.contains('field-delete-btn')) return;
                if (e.target !== element && element.contains(e.target)) {
                    // Prevent drag when interacting with input
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT') {
                        return;
                    }
                }

                isMouseDown = true;
                const rect = element.getBoundingClientRect();
                const parentRect = element.parentElement.getBoundingClientRect();
                offsetX = e.clientX - rect.left;
                offsetY = e.clientY - rect.top;

                element.style.zIndex = 1000;

                const handleMouseMove = (moveEvent) => {
                    if (!isMouseDown) return;

                    const x = moveEvent.clientX - parentRect.left - offsetX;
                    const y = moveEvent.clientY - parentRect.top - offsetY;

                    element.style.left = Math.max(0, Math.min(x, parentRect.width - element.offsetWidth)) + 'px';
                    element.style.top = Math.max(0, Math.min(y, parentRect.height - element.offsetHeight)) + 'px';

                    const idx = fields.findIndex(f => f.id === field.id);
                    if (idx >= 0) {
                        fields[idx].x = parseInt(element.style.left);
                        fields[idx].y = parseInt(element.style.top);
                    }
                };

                const handleMouseUp = () => {
                    isMouseDown = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                    element.style.zIndex = 'auto';
                };

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);
            });
        }

        function makeResizable(element, field) {
            let isResizing = false;

            element.addEventListener('mousedown', (e) => {
                const rect = element.getBoundingClientRect();
                const isHandle = (e.clientX >= rect.right - 12 && e.clientX <= rect.right + 6 &&
                                  e.clientY >= rect.bottom - 12 && e.clientY <= rect.bottom + 6);

                if (!isHandle) return;

                isResizing = true;
                const startX = e.clientX;
                const startY = e.clientY;
                const startWidth = element.offsetWidth;
                const startHeight = element.offsetHeight;

                const handleMouseMove = (moveEvent) => {
                    if (!isResizing) return;

                    const newWidth = Math.max(40, startWidth + (moveEvent.clientX - startX));
                    const newHeight = Math.max(20, startHeight + (moveEvent.clientY - startY));

                    element.style.width = newWidth + 'px';
                    element.style.height = newHeight + 'px';

                    const idx = fields.findIndex(f => f.id === field.id);
                    if (idx >= 0) {
                        fields[idx].width = newWidth;
                        fields[idx].height = newHeight;
                    }
                };

                const handleMouseUp = () => {
                    isResizing = false;
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                e.preventDefault();
            });
        }

        function deleteField(fieldId) {
            fields = fields.filter(f => f.id !== fieldId);
            renderFieldOverlays();
            showStatus('Field deleted', false);
        }

        // Button handlers
        [addTextBtn, addCheckboxBtn, addRadioBtn, addDropdownBtn].forEach(btn => {
            btn.addEventListener('click', () => {
                [addTextBtn, addCheckboxBtn, addRadioBtn, addDropdownBtn].forEach(b => b.classList.remove('active'));

                if (activeTool === btn.dataset.type) {
                    activeTool = null;
                    btn.classList.remove('active');
                    showStatus('Field placement cancelled', false);
                } else {
                    activeTool = btn.dataset.type;
                    btn.classList.add('active');
                    showStatus(`Click on the PDF to place a ${activeTool} field`, false);
                }
            });
        });

        clearFieldsBtn.addEventListener('click', () => {
            if (fields.length === 0) {
                showStatus('No fields to clear', true);
                return;
            }

            if (confirm('Are you sure you want to delete all fields? This cannot be undone.')) {
                fields = [];
                renderFieldOverlays();
                showStatus('All fields cleared', false);
            }
        });

        detectBoxesBtn.addEventListener('click', detectFormBoxes);

        downloadBtn.addEventListener('click', downloadFilledPDF);

        async function downloadFilledPDF() {
            if (!originalPdfBytes) {
                showStatus('No PDF loaded', true);
                return;
            }

            try {
                showStatus('Preparing PDF for download...', false);
                downloadBtn.disabled = true;

                const pdfData = await PDFLib.PDFDocument.load(originalPdfBytes);
                const pages = pdfData.getPages();

                for (const field of fields) {
                    if (field.page >= pages.length) continue;

                    const page = pages[field.page];
                    const pageHeight = page.getHeight();
                    const scale = pageScales[field.page] || PDF_SCALE;

                    // Convert canvas coordinates to PDF coordinates
                    // Canvas coords are scaled, so divide by scale factor
                    const pdfX = field.x / scale;
                    const pdfY = pageHeight - (field.y / scale) - (field.height / scale);
                    const pdfHeight = field.height / scale;

                    const fontSize = Math.max(8, Math.min(pdfHeight * 0.7, 14));

                    if (field.type === 'text') {
                        page.drawText(field.value, {
                            x: pdfX,
                            y: pdfY,
                            size: fontSize,
                            color: PDFLib.rgb(0, 0, 0)
                        });
                    } else if (field.type === 'checkbox') {
                        if (field.value) {
                            page.drawText('‚úì', {
                                x: pdfX + 2,
                                y: pdfY,
                                size: fontSize,
                                color: PDFLib.rgb(0, 0, 0)
                            });
                        }
                    } else if (field.type === 'radio') {
                        if (field.value === 'on') {
                            const pdfWidth = field.width / scale;
                            page.drawCircle({
                                x: pdfX + pdfWidth / 2,
                                y: pdfY + pdfHeight / 2,
                                size: pdfHeight / 3,
                                color: PDFLib.rgb(0, 0, 0),
                                borderColor: PDFLib.rgb(0, 0, 0),
                                borderWidth: 0
                            });
                        }
                    } else if (field.type === 'dropdown') {
                        page.drawText(field.value, {
                            x: pdfX,
                            y: pdfY,
                            size: fontSize,
                            color: PDFLib.rgb(0, 0, 0)
                        });
                    }
                }

                const pdfBytes = await pdfData.save();
                const blob = new Blob([pdfBytes], { type: 'application/pdf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'filled-form.pdf';
                a.click();
                URL.revokeObjectURL(url);

                showStatus('PDF downloaded successfully', false);
                downloadBtn.disabled = false;
            } catch (error) {
                showStatus(`Error downloading PDF: ${error.message}`, true);
                downloadBtn.disabled = false;
            }
        }

        function generateFieldId() {
            return 'field-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
        }

        function showStatus(message, isError) {
            status.textContent = message;
            status.className = 'visible';
            if (isError) {
                status.setAttribute('aria-invalid', 'true');
            } else {
                status.removeAttribute('aria-invalid');
            }
        }

        // Load OpenCV.js asynchronously
        function loadOpenCV() {
            return new Promise((resolve, reject) => {
                // Check if already loaded
                if (window.cv && window.cv.Mat) {
                    console.log('OpenCV already loaded');
                    opencvReady = true;
                    resolve();
                    return;
                }

                console.log('Starting OpenCV.js load...');

                // Create or get the script element
                let script = document.getElementById('opencvScript');
                if (!script) {
                    script = document.createElement('script');
                    script.id = 'opencvScript';
                    script.src = 'https://cdn.jsdelivr.net/npm/opencv.js@1.2.1/opencv.js';
                    script.async = true;
                }

                // Set up handlers
                const onLoadHandler = () => {
                    console.log('OpenCV.js loaded, checking if cv is available...');
                    // Wait a bit for cv to be available
                    setTimeout(() => {
                        if (window.cv && window.cv.Mat) {
                            console.log('OpenCV cv object is available');
                            opencvReady = true;
                            resolve();
                        } else {
                            console.error('OpenCV loaded but cv object not available');
                            reject(new Error('OpenCV loaded but cv object not available'));
                        }
                    }, 100);
                };

                const onErrorHandler = (error) => {
                    console.error('Failed to load OpenCV.js:', error);
                    reject(new Error('Failed to load OpenCV.js library: ' + error));
                };

                script.onload = onLoadHandler;
                script.onerror = onErrorHandler;

                // Append script if not already in DOM
                if (!script.parentElement) {
                    console.log('Appending OpenCV.js script to DOM');
                    document.head.appendChild(script);
                } else {
                    console.log('OpenCV.js script already in DOM, waiting for load...');
                }

                // Add a timeout in case the script fails silently
                setTimeout(() => {
                    if (!opencvReady && window.cv && window.cv.Mat) {
                        console.log('OpenCV available after timeout');
                        opencvReady = true;
                        resolve();
                    }
                }, 5000);
            });
        }

        // Detect rectangles in image data using OpenCV
        function detectRectanglesInImage(imageData) {
            if (!window.cv || !window.cv.Mat) {
                showStatus('OpenCV not loaded', true);
                return [];
            }

            try {
                // Convert to OpenCV Mat
                let src = cv.matFromImageData(imageData);
                let gray = new cv.Mat();
                let edges = new cv.Mat();
                let hierarchy = new cv.Mat();
                let contours = new cv.MatVector();

                // Convert to grayscale
                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);

                // Apply Gaussian blur to reduce noise
                cv.GaussianBlur(gray, gray, new cv.Size(DETECTION_CONFIG.GAUSSIAN_KERNEL, DETECTION_CONFIG.GAUSSIAN_KERNEL), 0);

                // Edge detection (Canny)
                cv.Canny(gray, edges, DETECTION_CONFIG.CANNY_LOW, DETECTION_CONFIG.CANNY_HIGH);

                // Find contours
                cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

                // Filter for rectangles
                let rectangles = [];
                for (let i = 0; i < contours.size(); i++) {
                    let contour = contours.get(i);
                    let approx = new cv.Mat();

                    // Approximate contour to polygon
                    let peri = cv.arcLength(contour, true);
                    cv.approxPolyDP(contour, approx, 0.02 * peri, true);

                    // Check if it's a rectangle (4 vertices)
                    if (approx.rows === 4) {
                        let rect = cv.boundingRect(approx);
                        let area = rect.width * rect.height;
                        let contourArea = cv.contourArea(contour);
                        let perimeter = cv.arcLength(contour, true);

                        // Filter by aspect ratio (not too elongated)
                        let aspectRatio = rect.width / rect.height;

                        // Calculate solidity (contour area / bounding box area)
                        let solidity = contourArea / area;

                        // Expected perimeter for a rectangle
                        let expectedPerimeter = 2 * (rect.width + rect.height);
                        // Allow 20% deviation from expected perimeter
                        let perimeterRatio = perimeter / expectedPerimeter;

                        if (aspectRatio >= DETECTION_CONFIG.MIN_ASPECT_RATIO &&
                            aspectRatio <= DETECTION_CONFIG.MAX_ASPECT_RATIO &&
                            solidity >= DETECTION_CONFIG.MIN_SOLIDITY &&
                            solidity <= DETECTION_CONFIG.MAX_SOLIDITY &&
                            perimeterRatio >= 0.8 && perimeterRatio <= 1.3) {  // Perimeter match check

                            // Check if this box overlaps with existing boxes (deduplication)
                            let isDuplicate = false;
                            for (let existing of rectangles) {
                                // Check if centers are close (within 15% of box size)
                                let dist = Math.hypot(
                                    (rect.x + rect.width/2) - (existing.x + existing.width/2),
                                    (rect.y + rect.height/2) - (existing.y + existing.height/2)
                                );
                                if (dist < Math.max(rect.width, rect.height) * 0.15) {
                                    // Keep the one with better solidity (closer to middle range)
                                    let existingSolidity = rectangles.find(r => r.solidity)?.solidity || 0;
                                    let targetSolidity = (DETECTION_CONFIG.MIN_SOLIDITY + DETECTION_CONFIG.MAX_SOLIDITY) / 2;
                                    if (Math.abs(solidity - targetSolidity) < Math.abs(existingSolidity - targetSolidity)) {
                                        rectangles = rectangles.filter(r => r !== existing);
                                        isDuplicate = false;
                                    } else {
                                        isDuplicate = true;
                                    }
                                    break;
                                }
                            }

                            if (!isDuplicate) {
                                rectangles.push({
                                    x: rect.x,
                                    y: rect.y,
                                    width: rect.width,
                                    height: rect.height,
                                    solidity: solidity
                                });
                            }
                        }
                    }

                    approx.delete();
                    contour.delete();
                }

                // Clean up
                src.delete();
                gray.delete();
                edges.delete();
                hierarchy.delete();
                contours.delete();

                return rectangles;
            } catch (error) {
                console.error('Rectangle detection error:', error);
                showStatus(`Detection error: ${error.message}`, true);
                return [];
            }
        }

        // Main detection function
        async function detectFormBoxes() {
            console.log('detectFormBoxes called');

            if (!pdfDoc) {
                console.log('No PDF loaded');
                showStatus('Please upload a PDF first', true);
                return;
            }

            if (isDetecting) {
                console.log('Detection already in progress');
                showStatus('Detection already in progress', true);
                return;
            }

            try {
                isDetecting = true;
                detectBoxesBtn.disabled = true;
                console.log('Starting detection...');
                showStatus('Loading detection library...', false);

                // Load OpenCV if not already loaded
                if (!opencvReady) {
                    await loadOpenCV();
                }

                showStatus('Detecting form boxes...', false);
                let totalDetected = 0;

                // For each rendered page
                for (let pageNum = 0; pageNum < pdfDoc.numPages; pageNum++) {
                    // Find canvas for this page
                    const canvas = document.querySelector(`.pdf-page-canvas[data-page="${pageNum + 1}"]`);
                    if (!canvas) continue;

                    showStatus(`Detecting boxes on page ${pageNum + 1}/${pdfDoc.numPages}...`, false);

                    try {
                        // Get image data
                        const ctx = canvas.getContext('2d');
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                        // Detect rectangles
                        const rectangles = detectRectanglesInImage(imageData);
                        console.log(`Page ${pageNum + 1}: Detected ${rectangles.length} total rectangles`);

                        // Log sizes of detected rectangles
                        if (rectangles.length > 0) {
                            const sizes = rectangles.map(r => `${r.width}x${r.height}`).slice(0, 10);
                            console.log(`  Sample sizes: ${sizes.join(', ')} ${rectangles.length > 10 ? '...' : ''}`);
                        }

                        // Filter for character-sized boxes
                        const characterBoxes = rectangles.filter(rect => {
                            const widthOk = rect.width >= DETECTION_CONFIG.MIN_BOX_SIZE && rect.width <= DETECTION_CONFIG.MAX_BOX_SIZE;
                            const heightOk = rect.height >= DETECTION_CONFIG.MIN_BOX_SIZE && rect.height <= DETECTION_CONFIG.MAX_BOX_SIZE;
                            return widthOk && heightOk;
                        });
                        console.log(`Page ${pageNum + 1}: After edge detection: ${rectangles.length} rects, after size filter: ${characterBoxes.length} boxes`);
                        console.log(`  Size range: ${DETECTION_CONFIG.MIN_BOX_SIZE}-${DETECTION_CONFIG.MAX_BOX_SIZE}px, Solidity: ${DETECTION_CONFIG.MIN_SOLIDITY}-${DETECTION_CONFIG.MAX_SOLIDITY}`);

                        // Create fields for each detected box
                        characterBoxes.forEach(box => {
                            fields.push({
                                id: generateFieldId(),
                                type: 'text',
                                page: pageNum,
                                x: Math.round(box.x),
                                y: Math.round(box.y),
                                width: Math.round(box.width),
                                height: Math.round(box.height),
                                value: '',
                                maxLength: 1,
                                isDetected: true
                            });
                        });

                        totalDetected += characterBoxes.length;
                    } catch (error) {
                        console.error(`Error detecting boxes on page ${pageNum + 1}:`, error);
                    }
                }

                // Re-render overlays with new fields
                renderFieldOverlays();

                // Show success message
                if (totalDetected > 0) {
                    showStatus(`‚úì Detected ${totalDetected} form boxes. Review and adjust as needed.`, false);
                } else {
                    showStatus('No form boxes detected. Try manually adding fields or check the PDF.', false);
                }
            } catch (error) {
                console.error('Detection error:', error);
                showStatus(`Error during detection: ${error.message}`, true);
            } finally {
                isDetecting = false;
                detectBoxesBtn.disabled = false;
            }
        }

        // Close field selection when clicking outside
        document.addEventListener('click', (e) => {
            if (!e.target.closest('.toolbar') && !e.target.closest('.pdf-page-wrapper')) {
                document.querySelectorAll('.field-overlay.selected').forEach(el => {
                    el.classList.remove('selected');
                });
            }
        });
    </script>
</body>
</html>
