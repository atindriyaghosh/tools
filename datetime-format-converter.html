<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DateTime Format Converter</title>
    <link rel="shortcut icon" type="image/png" href="favicon.png">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@picocss/pico@2/css/pico.min.css">
    <style>
        .tz-flex { display:flex; gap:1rem; align-items:center; flex-wrap:wrap }
        .result { margin-top: 1rem; padding:1rem; border:1px solid var(--pico-muted-border-color); border-radius:var(--pico-border-radius); background:var(--pico-card-background-color) }
        .small-note { font-size:0.9rem; color:var(--pico-muted-color) }
        .tz-list { max-height: 260px; overflow:auto; }
        a { color: #6b8dd6; }
        a.back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
            font-weight: bold;
            padding: 0.4rem 0.6rem;
            border-radius: var(--pico-border-radius);
            transition: all 0.2s;
            color: #6b8dd6;
        }
        a.back-link:hover {
            background-color: rgba(107, 141, 214, 0.1);
            color: #5b7dc6;
        }
        button { background-color: #6b8dd6; border-color: #6b8dd6; color: white; }
        button:hover { background-color: #5b7dc6; border-color: #5b7dc6; }
        button:disabled { background-color: #9baee6; border-color: #9baee6; opacity: 0.6; }
    </style>
</head>
<body>
    <main class="container">
        <p style="margin-bottom: 1rem;"><a href="index.html" class="back-link">← Back to Tools</a></p>
        <hgroup>
            <h1>DateTime Format Converter</h1>
            <p>Parse date/time strings using a format and output them in another format.</p>
        </hgroup>

        <section class="panel" id="format-converter">
            <label>
                Input date/time string
                <input type="text" id="formatInputText" placeholder="e.g. 2023-07-15 14:30:00">
            </label>

            <div class="tz-flex">
                <label>
                    Input format
                    <select id="inputFormat"></select>
                </label>

                <label>
                    Output format
                    <select id="outputFormat"></select>
                </label>

                <label>
                    Timezone
                    <select id="formatTz" class="tz-list"></select>
                </label>

                <button id="formatConvertBtn">Convert</button>
            </div>

            <div style="margin-top:0.5rem; display:flex; gap:0.5rem; align-items:center;">
                <input type="text" id="newFormatInput" placeholder="Custom format (e.g. YYYY-MM-DD HH:mm:ss)">
                <button id="addFormatBtn">Add format</button>
            </div>

            <div class="result" id="formatResult"></div>
            <p class="small-note">Supported tokens: <code>YYYY</code>, <code>MM</code>, <code>DD</code>, <code>HH</code>, <code>mm</code>, <code>ss</code></p>

            <p style="margin-top:1rem"><a href="index.html" class="back-link">← Back to Tools</a></p>
        </section>
    </main>

    <script>
        const standardFormats = ['YYYY-MM-DD HH:mm:ss','YYYY-MM-DD','MM/DD/YYYY HH:mm','DD MMM YYYY HH:mm:ss','ISO','RFC2822'];

        function populateTimeZones(selects) {
            const list = (typeof Intl.supportedValuesOf === 'function')
                ? Intl.supportedValuesOf('timeZone')
                : ['UTC','Etc/GMT','America/New_York','Europe/London','Asia/Tokyo','Asia/Kolkata','Australia/Sydney'];

            list.forEach(tz => selects.forEach(sel => { const opt = document.createElement('option'); opt.value = tz; opt.textContent = tz; sel.appendChild(opt); }));
            const local = Intl.DateTimeFormat().resolvedOptions().timeZone || 'UTC';
            selects.forEach(sel => { sel.value = local; });
        }

        function tzOffsetMinutes(date, timeZone) {
            const f = new Intl.DateTimeFormat('en-US', {
                timeZone,
                year: 'numeric', month: '2-digit', day: '2-digit',
                hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false
            });
            const parts = f.formatToParts(date).reduce((acc, p) => { if (p.type !== 'literal') acc[p.type] = p.value; return acc; }, {});
            const asUTC = Date.UTC(parts.year, parts.month - 1, parts.day, parts.hour, parts.minute, parts.second);
            const utcMs = date.getTime();
            const offsetMin = (utcMs - asUTC) / (60 * 1000);
            return Math.round(offsetMin);
        }

        function pad(n, len=2){ return String(n).padStart(len, '0'); }

        function formatDateWithPattern(instant, timeZone, pattern){
            if (pattern === 'ISO') return instant.toISOString();
            if (pattern === 'RFC2822') return new Date(instant.getTime()).toUTCString();
            const offsetMin = tzOffsetMinutes(instant, timeZone);
            const tzDate = new Date(instant.getTime() - offsetMin * 60 * 1000);
            const YYYY = tzDate.getUTCFullYear();
            const MM = pad(tzDate.getUTCMonth()+1);
            const DD = pad(tzDate.getUTCDate());
            const HH = pad(tzDate.getUTCHours());
            const mm = pad(tzDate.getUTCMinutes());
            const ss = pad(tzDate.getUTCSeconds());
            return pattern.replace(/YYYY/g, YYYY)
                          .replace(/MM/g, MM)
                          .replace(/DD/g, DD)
                          .replace(/HH/g, HH)
                          .replace(/mm/g, mm)
                          .replace(/ss/g, ss);
        }

        function patternToRegex(pattern){
            const esc = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
            const withGroups = esc.replace(/YYYY/g, '(\\d{4})')
                                  .replace(/MM/g, '(\\d{1,2})')
                                  .replace(/DD/g, '(\\d{1,2})')
                                  .replace(/HH/g, '(\\d{1,2})')
                                  .replace(/mm/g, '(\\d{1,2})')
                                  .replace(/ss/g, '(\\d{1,2})');
            return new RegExp('^' + withGroups + '$');
        }

        function parseDateFromPattern(input, pattern, timeZone){
            if (pattern === 'ISO' || pattern === 'RFC2822'){
                const d = new Date(input);
                if (isNaN(d)) return null;
                return d;
            }
            const re = patternToRegex(pattern);
            const m = input.match(re);
            if (!m) return null;

            const tokenOrder = [];
            const tokenRegex = /(YYYY|MM|DD|HH|mm|ss)/g;
            let match;
            while ((match = tokenRegex.exec(pattern)) !== null) tokenOrder.push(match[1]);

            const comps = { y:1970, m:1, d:1, hour:0, minute:0, second:0 };
            for (let i=0;i<tokenOrder.length;i++){
                const tok = tokenOrder[i];
                const val = Number(m[i+1] || 0);
                if (tok === 'YYYY') comps.y = val;
                else if (tok === 'MM') comps.m = val;
                else if (tok === 'DD') comps.d = val;
                else if (tok === 'HH') comps.hour = val;
                else if (tok === 'mm') comps.minute = val;
                else if (tok === 'ss') comps.second = val;
            }

            // Interpret as wall time in the timezone
            const utcCandidate = Date.UTC(comps.y, comps.m - 1, comps.d, comps.hour, comps.minute, comps.second);
            const approxDate = new Date(utcCandidate);
            const offsetMin = tzOffsetMinutes(approxDate, timeZone);
            const instantMs = utcCandidate - (offsetMin * 60 * 1000);
            return new Date(instantMs);
        }

        function convertFormat(){
            const input = document.getElementById('formatInputText').value.trim();
            const inFmt = document.getElementById('inputFormat').value;
            const outFmt = document.getElementById('outputFormat').value;
            const tz = document.getElementById('formatTz').value;
            const resultEl = document.getElementById('formatResult');
            if (!input){ resultEl.textContent = 'Enter input string to convert'; return; }
            const instant = parseDateFromPattern(input, inFmt, tz);
            if (!instant || isNaN(instant)){ resultEl.textContent = 'Unable to parse input using selected format'; return; }
            const outStr = formatDateWithPattern(instant, tz, outFmt);
            resultEl.innerHTML = `<strong>Parsed ISO (UTC):</strong> ${instant.toISOString()}<br><strong>Result:</strong> ${outStr}`;
        }

        function addFormat(){
            const v = document.getElementById('newFormatInput').value.trim();
            if (!v) return;
            const inputSel = document.getElementById('inputFormat'), outSel = document.getElementById('outputFormat');
            [inputSel,outSel].forEach(sel=>{
                if (![...sel.options].some(o=>o.value===v)){
                    const opt = document.createElement('option'); opt.value = v; opt.textContent = v; sel.appendChild(opt);
                }
            });
            document.getElementById('newFormatInput').value='';
        }

        document.addEventListener('DOMContentLoaded', () => {
            populateTimeZones([document.getElementById('formatTz')]);
            const inFmtSel = document.getElementById('inputFormat');
            const outFmtSel = document.getElementById('outputFormat');
            standardFormats.forEach(f => { [inFmtSel, outFmtSel].forEach(sel => { const opt = document.createElement('option'); opt.value = f; opt.textContent = f; sel.appendChild(opt); }); });
            inFmtSel.value = 'YYYY-MM-DD HH:mm:ss';
            outFmtSel.value = 'ISO';
            document.getElementById('formatConvertBtn').addEventListener('click', convertFormat);
            document.getElementById('addFormatBtn').addEventListener('click', addFormat);
            document.getElementById('formatInputText').addEventListener('keyup', (e) => { if (e.key === 'Enter') convertFormat(); });
        });
    </script>
</body>
</html>
